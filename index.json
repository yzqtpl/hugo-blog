[{"content":" 记得进入设置\u0026gt;工作空间行为\u0026gt;锁屏\u0026gt;关闭自动锁屏，不然会卡死在登陆\n分区工具的使用 partitionmanager  sudo yay -S partitionmanager  pacman 的日常使用  安装todesk远程控制\nyay -Ss todesk 找到todesk yay -S todesk-bin # 需要开启u服务 systemctl start todeskd.service pacman -S xx1 xx2 # 安装或升级软件包，或者一列软件包（包含依赖包） pacman -Sy # 更新软件源 pacman -Syy # 强制更新软件源 pacman -Su # 更新软件包 pacman -Syu # 更新软件源并更新软件包（-Syyu） pacman -Sc # 清除软件包缓存 pacman -Ss xxx # 搜索名字含 xxx 的软件 pacman -Ss ^xxx # 搜索名字以 xxx 开头的软件 pacman -R xxx # 删除单个软件包，保留其安装的依赖关系 pacman -Rs xxx # 删除指定软件包，及其没有被其他已安装软件包使用的依赖关系 pacman -Rn xxx # 一并删除全局配置文件 pacman -Rns xxx # 删除一个软件的推荐命令 pacman -Rns $(pacman -Qdtq) # 删除没有依赖的包 pacman -Q # 查询本地软件包数据库 pacman -Qq # 查询本地软件包数据库，但不显示版本信息 pacman -Qe # 查询非系统自带软件包数据库 pacman -Q | wc -l # 查看有多少本地软件包 pacman -Qs regex # 按正则表达式查询软件包 pacman -Qdt # 查看没有依赖的包 更换源 //1.配置镜像源: sudo pacman-mirrors -i -c China -m rank //2.设置 archlinuxcn 源, #使用方法：在 /etc/pacman.conf 文件末尾添加以下两行：  [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch  # 之后安装 archlinuxcn-keyring 包导入 GPG key。 //3.更新源列表 sudo pacman-mirrors -g //4.更新pacman数据库并全面更新系统 sudo pacman -Syyu //5.更新签名 sudo pacman -S archlinuxcn-keyring //6.安装yay,e更换aur的源 sudo pacman -S yay git net-tools tree vim //7.执行以下命令修改 aururl : yay --aururl \u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; --save //8.修改的配置文件位于 `~/.config/yay/config.json` ，还可通过以下命令查看修改过的配置： yay -P -g 以后就可以直接执行yay -S 你要安装的软件名字，比如 yay -S netease-cloud-music 更新文件夹语言 export LANG=en_US xdg-user-dirs-gtk-update //弹出对话框，问是否改成英文，点是，并且选“不再提示” export LANG=zh_CN 安装常用的软件： yay -S net-tools base-devel 浏览器我推荐brave浏览器 yay -S brave chrome浏览器： yay -S google-chrome Microsoft-edge浏览器：yay -S microsoft-edge-dev-bin Git软件： yay -S git Uget配合aria2： yay -S aria2 下载工具： yay -S uget 解压工具： yay -S p7zip file-roller unrar 图像编辑器： yay -S gimp （开源版PS） WPS办公： yay -S wps-office WPS缺少的字体： yay -S ttf-wps-fonts WPS安装中文： sudo pacman -S wps-office-mui-zh-cn Vscode开发工具： yay -S visual-studio-code-bin Markdown编辑器： yay -S typora 强大的Web内容（视频，音频，图片）下载工具： yay -S you-get 火焰截图： yay -S flameshot (超好用,系统设置里面添加快捷键即可) 云笔记软件： yay -S joplin (开源免费，云服务需要飞天服务) chm文件阅读器： yay -S kchmviewer 有道词典： yay -S youdao-dict 开源电子书阅读器： yay -S calibre MD文件编辑器： yay -S typora Gif录制软件： yay -S peek sudo pacman -S filezilla # 关闭电子钱包 用了kde以后，每次打开浏览器都会跳出电子钱包什么的，十分烦人，也可能是我自己不习惯 于是就想办法把他关掉！ 搜索Kwallet， 不是KwalletManager 然后把启用的勾勾去掉就好啦 安装docker： sudo pacman -S docker sudo pacman -S docker-compose 安装java： （https://wiki.archlinux.org/index.php/Java#Installation）\n sudo pacman -S java-runtime-common java-environment-common yay jdk8 # Select extra/jdk8-openjdk 使用 archlinux-java 命令来管理 Java 环境。 列举 Java 环境： archlinux-java status 选择 Java 环境： sudo archlinux-java set java-8-openjdk  打开.bashrc # 在后面加上， 地址根据你jdk修改 export JAVA_HOME=/home/hxy/java/jdk-13 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH  # 启用配置，不过我这边不知道怎么退出（我是强制关掉） source .bashrc  # 查看是否配置成功 java -version 安装node,nvm，yarn： 先配置下载github太慢  kate /etc/hosts 在最后添加 199.232.68.133 raw.githubusercontent.com # 1.下载nvm脚本文件 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.36.0/install.sh | bash # 2. 或者： export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node # 注：如果只是在终端输入了上面的代码只能在本次窗口没有关闭的时候生效，下次打开还是会还原成默认的源 # 如果需要长久的使用淘宝源则需要如下操作 # 确认你的sh是什么，一般bash或者zsh # 如果是 bash 则键入  echo \u0026#34;export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile  # 如果是 zsh 则输入  echo \u0026#34;export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\u0026#34; \u0026gt;\u0026gt; ~/.zshrc  # 最后再分别执行命令  # bash 为 ：source ~/.bash_profile  # zsh 为 ：source ~/.zshrc 等同于 在.bashrc中添加下面的内容 export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node 3.下载node,配置国内镜像 nvm install node 设置npm国内镜像 npm config set registry https://registry.npm.taobao.org 安装镜像服务 npm i -g mirror-config-china npm i -g yarn 设置yarn镜像（可以做成一个a.sh脚本执行） yarn config set registry https://registry.npm.taobao.org -g yarn config set disturl https://npm.taobao.org/dist -g yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -g yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -g yarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -g yarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -g yarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g 安装miniconda： 从清华镜像下载miniconda执行的sh  https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/   配置conda国内镜像  i在.condarc中加入下面的：  channels:  - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  安装Anaconda后终端出现的(base)字样去除方法：\nconda config --set auto_activate_base False 安装输入法： 设置小键盘开机自动启动方法 打开设置 找到输入设备-\u0026gt;键盘 -\u0026gt; plasma启动时numlock状态-\u0026gt;开启即可 关闭触控板也是输入设备-\u0026gt;触摸板\n下载fcitx5并安装 sudo yay -S fcitx5 fcitx5-chinese-addons fcitx5-rime fcitx5-chewing fcitx5-configtool 1、在用户文件夹下创建.xprofile配置文件  输入命令 sudo vim ~/.xprofile  然后插入如下内容 export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx 2、设置fcitx5为开机启动 ①: 直接在~/.xprofile中插入下面这行 fcitx5 \u0026amp; ②: 如果是KDE用户，可在系统设置-启动和关闭-自启动中填加fcitx5为开机自启动项 编辑~`/.pam_environment` INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 安装golang: 1.使用pacman/yay sudo pacman -S go go-tools  可选用 gcc-go ，但若需要使用 JetBrains 的 IDE 则必须使用 go ，否则 IDE 无法在 /usr/lib/go 下找到 Go SDK。\n 2.从官网下载 在golang官网下载go的安装包，go1.16.linux-amd64.tar.gz 然后 # 1.解压到local目录 wget https://golang.google.cn/dl/go1.16.4.linux-amd64.tar.gz sudo tar -C /opt -xzf go1.16.4.linux-amd64.tar.gz # 2.编辑环境变量，在/etc/profile和.bashrc添加 #vim ~/.zshrc # OR ~/.bashrc OR ~/.profile cp -r ~/.bashrc ~/bashrcbak # 添加a环境变量 export GOMODPATH=/opt/go export PATH=\u0026#34;$GOMODPATH/bin:$GOMODPATH/golangmod/bin:$PATH\u0026#34; # 修改/opt的权限 sudo chmod -R 777 /opt/go    echo \u0026#39;export GOMODPATH=/opt/go export PATH=\u0026#34;$GOMODPATH/bin:$GOMODPATH/golangmod/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt;~/.bashrc source ~/.bashrc # 3.输入go version检查是否有安装成功 # 4.配置go代理 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go env -w GOPATH=/opt/go/golangmod 安装teamviewer yay -S teamviewer 提示：TeamViewer Daemon is not running，解决方法： sudo teamviewer --daemon enable 安装myql：（已经被替换为mariadb,请使用下面的方法） 如果要使用mysql8,需要设置aur！！！！！！！\n//下载Mysql pacman -S mysql //初始化Mysql，记住生成的密码，方便修改 sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql //设置开机启动 systemctl enable mysqld.service //启动Mysql sudo systemctl start mysqld.service //修改密码 mysql -u root -p mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;新密码\u0026#39;; 如果忘记密码，直接百度mysql8忘记密码怎么办\nmanjaro 。忘记密码解决办法： # 1.先编辑mysql配置文件 kate /etc/mysql/my.cnf # 2.添加一个 skip-grant-tables # 3. 重启mysql服务 sudo systemctl restart mysqld # 4.进入mysql 直接在命令行进入lmysql # 5 设置 root密码为空 mysql\u0026gt;use mysql; mysql\u0026gt;update user set authentication_string=\u0026#39;\u0026#39; where user=\u0026#39;root\u0026#39;; #将密码置空  mysql\u0026gt;exit #6 去掉mysql配置文件里的 skip-grant-tables 重新登陆mysql使用 mysql -uroot -p #两次确定就可进去 #7. ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;新密码\u0026#39;;# 然后退出mysql登陆就可以了 如果出现 ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 命令行进入mysql输入\nALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39; 就可以连上了\n安装mariadb ##1. 安装 与Ubuntu不同，arch默认已经不再支持MySQL，但是可以安装MariaDB，其比MySQL的性能更好且操作基本相同。 输入下面命令安装：\nsystemctl stop mysqld //停止mysql服务 sudo pacman -S mariadb libmariadbclient mariadb-clients //安装mariadb sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 复制代码 ##2. 启动\nsystemctl start mariadb mysql_secure_installation //设置密码等管理操作 systemctl restart mariadb 复制代码 登录：\nmysql -u root -p 安装postgressql 安装：\nsudo pacman -S postgresql 初始化(必须)：\nsudo su - postgres -c \u0026#34;initdb --locale zh_CN.UTF-8 -E UTF8 -D \u0026#39;/var/lib/postgres/data\u0026#39;\u0026#34; 其中，我将原本的en_US改为了zh_CN，未见异常。想要撤销的话，只需要把'/var/lib/postgres/data'下面的内容清空。 启动/开机启动 PostgreSQL：\nsystemctl start postgresql.service systemctl enable postgresql.service 切换到postgres用户，然后登录（初始无密码）：\nsudo -i -u postgres psql 要退出psql或返回原用户，都是用exit命令。 PostgreSQL的用户跟系统用户有些关联，前者必须也是后者。在初始化过程中会在系统中创建postgres用户，同时也是数据库的超级权限用户，postgres用户可以创建其他数据库用户。\n 提示： 如果创建一个与你的系统用户同名的数据库用户，并允许其访问 PostgreSQL 数据库，那么在登录PostgreSQL 数据库 shell 的时候无需切换用户（这样做会比较方便）。\n 通用基本操作[1] 数据库shell外 添加数据库（须在原用户操作）：\ncreatedb myDatabaseName 连接数据库shell（须用postgres用户，所以先切一下用户）：\nsudo -i -u postgres psql -d myDatabaseName 也可以一步进入postgres用户的myDatabaseName数据库，与上面效果一样：\npsql -U postgres -d myDatabaseName 若要创建用户，要在数据库程序外，用postgres用户执行：\ncreateuser --interactive myUserName 数据库shell内 注意：数据库内的SQL语句，建议大写，必须分号结尾。 进入数据库后可修改密码：\nalter user postgres with password \u0026#39; *** 密码 *** \u0026#39;; 如果有其他用户，可以把postgres换成其他用户的名。 一些常用的命令：\n\\c myDatabaseName # 连接到数据库myDatabaseName \\du # 列出所有用户以及他们的权限 \\dt # 展示当前数据库中所有的表相关的汇总信息 \\q # 退出psql 开启ssh服务 systemctl enable sshd.service 开机启动 systemctl start sshd.service 立即启动 systemctl restart sshd.service 立即重启 安装nginx： yay -S nginx-mainline 安装redis： yay -S redis  1 启动服务端 sudo redis-server 启动redis 2 启动客户端 sudo redis-cli systemctl redis start # 关闭redis systemctl redis stop # 开机自启动 systemctl enable redis 配置redis密码：在/etc/redis.conf中找到requirepass,去掉h注释并更换为自己的密码； 出现\nSystem limit for number of file watchers reached echo fs.inotify.max_user_watches = 524288 | sudo tee -a /etc/sysctl.conf sudo sysctl -p 安装php和composer 安装php：\nyay -S php 第一步，下载composer。（切换到项目的根目录，再执行）\nphp -r \u0026#34;readfile(\u0026#39;https://getcomposer.org/installer\u0026#39;);\u0026#34; | php 下载之后后自动安装，执行 php composer.phar。查看composer是否安装成功。 第二步，将composer.phar文件移动到bin目录以便全局使用composer命令\ncp -r composer.phar /usr/local/bin/composer （如果只是针对某个项目使用composer,可忽略此步） 第三步，切换国内源（如果第一步下载成功，可忽略此步）\ncomposer config -g repo.packagist composer https://packagist.phpcomposer.com 第四步，安装phpcgi\nyay -S php-apache php-cgi php-fpm php-gd php-embed php-intl php-imap php-redis php-snmp 第五步，安装pecl\nwget http://pear.php.net/go-pear.phar php go-pear.phar 第六步，安装xdebug\nsudo pecl install xdebug  //为php.ini 添加 extension=xdebug.so sudo vim /etc/php/php.ini sudo systemctl reload php-fpm ","permalink":"https://yzqtpl.github.io/hugo-blog/post/manjarolinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/","summary":"康师傅理发店开始发生来得快快递费卡手的浪费","title":"生活"},{"content":"生活中的真理 曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。 如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。 如果非要在这份爱上加上一个期限，我希望是…… 一万年\n如果你浪费了自己的年龄，那是挺可悲的。因为你的青春只能持续一点儿时间——很短的一点儿时间。 —— 王尔德\n题诗寄汝非无意，莫负青春取自惭。 —— 于谦\n乐观的人永葆青春。 —— 拜伦\n青春，就像受赞美的春天。 —— 勃特勒\n友谊有许多名字，然而一旦有青春和美貌介入，友谊便被称作爱情，而且被神化为最美丽的天使。 —— 克里索斯尔\n青春像只唱着歌的鸟儿，已从残冬窗里闯出来，驶放宝蓝的穹窿里去了。 —— 闻一多\n长大以后，你悟出过哪些不一样的道理？  来自知乎\n 1.太不漂亮和太过漂亮，都不是什么好事，过多地关注容易让人迷失。\n2.侥幸位居高位，不是幸运，恰恰是不幸的开始。实力与位置不匹配，早晚摔得很惨。\n3.以前我觉得善于交际很厉害，后来我发现我错了，能够独行的人才是真的狠。\n4.原来情商高这个词儿，在实力超群面前无力极了，只要你能做到无法替代。\n5.以前我觉得成绩不重要，清北复交只能代表学生时代的成就。后来我发现，努力是种习惯，它会贯穿终生。\n6.仅仅努力是没用的，一个人成功与否，与天赋有着密不可分的联系。选择适合自己的方向最为重要\n7.为什么会觉得焦虑，因为你清楚每天做的事情毫无意义。当你开始做一点事情，就会发现心态开始改变\n8.选专业这件事，你喜欢才是最重要的。它热门与否，赚钱与否，好不好就业，都是在你能不能学好的前提下进行讨论。\n你不喜欢连学都不学，那些都是后话了。\n9.以前以为高考很重要是人生转折点，后来才发现，高考之后的四年大学才是人生的转折点。\n10.别人说你的时候别急着反驳，先想想他说的对不对。\n11.君子小人都不要得罪，在你根基不够稳的时候，少说多做才是对的，多听多听多听\n12.朋友不是用来宣泄负能量的！每个人都有自己的事情要办，没有人喜欢情绪一直down的人\n13.不要神化某种职业，任何职业都是，根本都是生存方式，大家都是人，放大镜下无完人\n14.要如何努力才能成为很厉害的人？现着手去做，先把手头的事尽力做到最好，不遗余力。\n最后。\n人活着不应该尽力而为，\n应当全力以赴。\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E7%94%9F%E6%B4%BB/","summary":"\u003ch2 id=\"生活中的真理\"\u003e生活中的真理\u003c/h2\u003e\n\u003cp\u003e曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。\n如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。\n如果非要在这份爱上加上一个期限，我希望是……\n一万年\u003c/p\u003e\n\u003cp\u003e如果你浪费了自己的年龄，那是挺可悲的。因为你的青春只能持续一点儿时间——很短的一点儿时间。 —— 王尔德\u003c/p\u003e","title":"生活"},{"content":"前端 标签： 干货\nJavaScript 优雅的实现方式包含你可能不知道的知识点 有些东西很好用，但是你未必知道；有些东西你可能用过，但是你未必知道原理。\n实现一个目的有多种途径，俗话说，条条大路通罗马。很多内容来自平时的一些收集以及过往博客文章底下的精彩评论，收集整理拓展一波，发散一下大家的思维以及拓展一下知识面。\n茴字有四种写法，233333\u0026hellip;， 文末有彩蛋有惊喜。\n1、简短优雅地实现 sleep 函数 很多语言都有 sleep 函数，显然 js 没有，那么如何能简短优雅地实现这个方法？\n1.1 普通版 function sleep(sleepTime) { \tfor(var start = +new Dat e; +new Date - start \u0026lt;= sleepTime;) {} } var t1 = +new Date() sleep(3000) var t2 = +new Date() console.log(t2 - t1) 优点：简单粗暴，通俗易懂。 缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升，无论你的服务器 CPU 有多么 Niubility。\n1.2 Promise 版本 function sleep(time) {  return new Promise(resolve =\u0026gt; setTimeout(resolve, time)) }  const t1 = +new Date() sleep(3000).then(() =\u0026gt; {  const t2 = +new Date()  console.log(t2 - t1) }) 优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。 缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭。\n1.3 Generator 版本 function sleep(delay) {  return function(cb) {  setTimeout(cb.bind(this), delay)  }; }  function* genSleep() {  const t1 = +new Date()  yield sleep(3000)  const t2 = +new Date()  console.log(t2 - t1) }  async(genSleep)  function async(gen) {  const iter = gen()  function nextStep(it) {  if (it.done) return  if (typeof it.value === \u0026#34;function\u0026#34;) {  it.value(function(ret) {  nextStep(iter.next(ret))  })  } else {  nextStep(iter.next(it.value))  }  }  nextStep(iter.next()) } 优点：同 Promise 优点，另外代码就变得非常简单干净，没有 then 那么生硬和恶心。 缺点：但不足也很明显，就是每次都要执行 next() 显得很麻烦，虽然有 co（第三方包）可以解决，但就多包了一层，不好看，错误也必须按 co 的逻辑来处理，不爽。\nco 之所以这么火并不是没有原因的，当然不是仅仅实现`` sleep 这么无聊的事情，而是它活生生的借着generator/yield 实现了很类似 async/await `的效果！这一点真是让我三观尽毁刮目相看。\nconst co = require(\u0026#34;co\u0026#34;) function sleep(delay) {  return function(cb) {  setTimeout(cb.bind(this), delay)  } }  co(function*() {  const t1 = +new Date()  yield sleep(3000)  const t2 = +new Date()  console.log(t2 - t1) }) 1.4 Async/Await 版本 function sleep(delay) {  return new Promise(reslove =\u0026gt; {  setTimeout(reslove, delay)  }) }  !async function test() {  const t1 = +new Date()  await sleep(3000)  const t2 = +new Date()  console.log(t2 - t1) }() 优点：同 Promise 和 Generator 优点。 Async/Await 可以看做是 Generator 的语法糖，Async 和 Await 相较于 * 和 yield 更加语义，另外各个函数都是扁平的，不会产生多余的嵌套，代码更加清爽易读。 缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题\n至于 Async/Await 比 Promise 和 Generator 的好处可以参考这两篇文章： Async/Await 比 Generator 的四个改进点 关于Async/Await替代Promise的6个理由\n1.5 不要忘了开源的力量 在 javascript 优雅的写 sleep 等于如何优雅的不优雅，2333\n 这里有 C++ 实现的模块：https://github.com/ErikDubbelboer/node-sleep\n const sleep = require(\u0026#34;sleep\u0026#34;)  const t1 = +new Date() sleep.msleep(3000) const t2 = +new Date() console.log(t2 - t1) 优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。 缺点：缺点需要安装这个模块，^_^，这也许算不上什么缺点。\n从一个间简简单单的 sleep 函数我们就就可以管中窥豹，看见 JavaScript 近几年来不断快速的发展，不单单是异步编程这一块，还有各种各样的新技术和新框架，见证了 JavaScript 的繁荣。\n你可能不知道的前端知识点：Async/Await是目前前端异步书写最优雅的一种方式\n2、获取时间戳 上面第一个用多种方式实现 sleep 函数，我们可以发现代码有 +new Date()获取时间戳的用法，这只是其中的一种，下面就说一下其他两种以及 +new Date()的原理。\n2.1 普通版 var timestamp=new Date().getTime() 优点：具有普遍性，大家都用这个 缺点：目前没有发现\n2.2 进阶版 var timestamp = (new Date()).valueOf()  valueOf 方法返回对象的原始值(Primitive,\u0026lsquo;Null\u0026rsquo;,\u0026lsquo;Undefined\u0026rsquo;,\u0026lsquo;String\u0026rsquo;,\u0026lsquo;Boolean\u0026rsquo;,\u0026lsquo;Number\u0026rsquo;五种基本数据类型之一)，可能是字符串、数值或 bool 值等，看具体的对象。\n 优点：说明开发者原始值有一个具体的认知，让人眼前一亮。 缺点: 目前没有发现\n2.3 终极版 var timestamp = +new Date() 优点：对 JavaScript 隐式转换掌握的比较牢固的一个表现 缺点：目前没有发现\n现在就简单分析一下为什么 +new Date() 拿到的是时间戳。\n一言以蔽之，这是隐式转换的玄学，实质还是调用了 valueOf() 的方法。\n我们先看看 ECMAScript 规范对一元运算符的规范：\n一元+ 运算符\n一元 + 运算符将其操作数转换为 Number 类型并反转其正负。注意负的 +0 产生 -0，负的 -0 产生 +0。产生式 UnaryExpression : - UnaryExpression 按照下面的过程执行。\n  令 expr 为解释执行 UnaryExpression 的结果 . 令 oldValue 为 ToNumber(GetValue(expr)). 如果 oldValue is NaN ，return NaN. 返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。   +new Date() 相当于 ToNumber(new Date())\n我们再来看看 ECMAScript 规范对 ToNumber 的定义：\n\n我们知道 new Date() 是个对象，满足上面的 ToPrimitive()，所以进而成了 ToPrimitive(new Date())。\n接着我们再来看看 ECMAScript 规范对 ToPrimitive 的定义，一层一层来，抽丝剥茧。\n\n这个 ToPrimitive 刚开始可能不太好懂，我来大致解释一下吧：\nToPrimitive(obj,preferredType)\nJavaScript 引擎内部转换为原始值 ToPrimitive(obj,preferredType) 函数接受两个参数，第一个 obj 为被转换的对象，第二个preferredType 为希望转换成的类型（默认为空，接受的值为 Number 或 String）\n在执行 ToPrimitive(obj,preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为Number 如果 preferredType为 Number，ToPrimitive 执行过程如下：\n  如果obj为原始值，直接返回； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则抛异常。   如果 preferredType 为 String，将上面的第2步和第3步调换，即：\n  如果obj为原始值，直接返回； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则抛异常。   首先我们要明白 obj.valueOf() 和 obj.toString() 还有原始值分别是什么意思,这是弄懂上面描述的前提之一:\ntoString 用来返回对象的字符串表示。\nvar obj = {}; console.log(obj.toString());//[object Object]  var arr2 = []; console.log(arr2.toString());//\u0026#34;\u0026#34;空字符串  var date = new Date(); console.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间) valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。\nvar obj = {  name: \u0026#34;obj\u0026#34; } console.log(obj.valueOf()) //Object {name: \u0026#34;obj\u0026#34;}  var arr1 = [1] console.log(arr1.valueOf()) //[1]  var date = new Date() console.log(date.valueOf())//1456638436303 如代码所示，三个不同的对象实例调用valueOf返回不同的数据 原始值指的是 \u0026lsquo;Null\u0026rsquo;,\u0026lsquo;Undefined\u0026rsquo;,\u0026lsquo;String\u0026rsquo;,\u0026lsquo;Boolean\u0026rsquo;,\u0026lsquo;Number\u0026rsquo;,\u0026lsquo;Symbol\u0026rsquo; 6种基本数据类型之一，上面已经提到过这个概念，这里再次申明一下。\n最后分解一下其中的过程：+new Date():\n  运算符 new 的优先级高于一元运算符 +，所以过程可以分解为： var time=new Date(); +time 根据上面提到的规则相当于：ToNumber(time) time 是个日期对象，根据 ToNumber 的转换规则，所以相当于：ToNumber(ToPrimitive(time)) 根据 ToPrimitive 的转换规则：ToNumber(time.valueOf())，time.valueOf() 就是 原始值 得到的是个时间戳，假设 time.valueOf()=1503479124652 所以 ToNumber(1503479124652) 返回值是 1503479124652 这个数字。 分析完毕   你可能不知道的前端知识点：隐式转换的妙用\n3、数组去重 注：暂不考虑对象字面量，函数等引用类型的去重，也不考虑 NaN, undefined, null等特殊类型情况。\n 数组样本：[1, 1, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, 1]\n 3.1 普通版 无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。\nvar a = [1, 1, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, 1] function unique(arr) {  var res = []  for (var i = 0, len = arr.length; i \u0026lt; len; i++) {  var item = arr[i]  for (var j = 0, len = res.length; j \u0026lt; jlen; j++) {  if (item === res[j]) //arr数组的item在res已经存在,就跳出循环  break  }  if (j === jlen) //循环完毕,arr数组的item在res找不到,就push到res数组中  res.push(item)  }  return res } console.log(unique(a)) // [1, 2, \u0026#34;1\u0026#34;] 优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本 缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高O(n^2)\n3.2 进阶版 var a = [1, 1, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, 1] function unique(arr) {  return arr.filter(function(ele,index,array){  return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的  }) } console.log(unique(a)) // [1, 2, \u0026#34;1\u0026#34;] 优点：很简洁，思维也比较巧妙，直观易懂。 缺点：不支持 IE9 以下的浏览器，时间复杂度还是O(n^2)\n3.3 时间复杂度为O(n) var a = [1, 1, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, 1] function unique(arr) {  var obj = {}  return arr.filter(function(item, index, array){  return obj.hasOwnProperty(typeof item + item) ?  false :  (obj[typeof item + item] = true)  }) }  console.log(unique(a)) // [1, 2, \u0026#34;1\u0026#34;] 优点：hasOwnProperty 是对象的属性(名称)存在性检查方法。对象的属性可以基于 Hash 表实现，因此对属性进行访问的时间复杂度可以达到O(1); filter 是数组迭代的方法，内部还是一个 for 循环，所以时间复杂度是 O(n)。 缺点：不兼容 IE9 以下浏览器，其实也好解决，把 filter 方法用 for 循环代替或者自己模拟一个 filter 方法。\n3.4 终极版  以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n const unique = a =\u0026gt; [...new Set(a)] 优点：ES6 语法，简洁高效，我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 缺点：兼容性问题，现代浏览器才支持，有 babel 这些都不是问题。\n你可能不知道的前端知识点：ES6 新的数据结构 Set 去重\n4、数字格式化 1234567890 \u0026ndash;\u0026gt; 1,234,567,890 4.1 普通版 function formatNumber(str) {  let arr = [],  count = str.length   while (count \u0026gt;= 3) {  arr.unshift(str.slice(count - 3, count))  count -= 3  }   // 如果是不是3的倍数就另外追加到上去  str.length % 3 \u0026amp;\u0026amp; arr.unshift(str.slice(0, str.length % 3))   return arr.toString()  } console.log(formatNumber(\u0026#34;1234567890\u0026#34;)) // 1,234,567,890 优点：自我感觉比网上写的一堆 for循环 还有 if-else 判断的逻辑更加清晰直白。 缺点：太普通\n4.2 进阶版 function formatNumber(str) { // [\u0026#34;0\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;1\u0026#34;] return str.split(\u0026#34;\u0026#34;).reverse().reduce((prev, next, index) =\u0026gt; { return ((index % 3) ? next : (next + \u0026#39;,\u0026#39;)) + prev }) } console.log(formatNumber(\u0026#34;1234567890\u0026#34;)) // 1,234,567,890 优点：把 JS 的 API 玩的了如指掌 缺点：可能没那么好懂，不过读懂之后就会发出我怎么没想到的感觉\n4.3 正则版 function formatNumber(str) { return str.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \u0026#39;,\u0026#39;) } console.log(formatNumber(\u0026#34;123456789\u0026#34;)) // 1,234,567,890 下面简单分析下正则/\\B(?=(\\d{3})+(?!\\d))/g：\n  /\\B(?=(\\d{3})+(?!\\d))/g：正则匹配边界\\B，边界后面必须跟着(\\d{3})+(?!\\d); (\\d{3})+：必须是1个或多个的3个连续数字; (?!\\d)：第2步中的3个数字不允许后面跟着数字; (\\d{3})+(?!\\d)：所以匹配的边界后面必须跟着3*n（n\u0026gt;=1）的数字。   最终把匹配到的所有边界换成,即可达成目标。\n优点：代码少，浓缩的就是精华 缺点：需要对正则表达式的位置匹配有一个较深的认识，门槛大一点\n4.4 API版 (123456789).toLocaleString(\u0026#39;en-US\u0026#39;) // 1,234,567,890 如图，你可能还不知道 JavaScript 的 toLocaleString 还可以这么玩。\n\n还可以使用 Intl对象 - MDN\n Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比，数字格式化，日期和时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。\n new Intl.NumberFormat().format(1234567890) // 1,234,567,890 优点：简单粗暴，直接调用 API 缺点：Intl兼容性不太好，不过 toLocaleString的话 IE6 都支持\n你可能不知道的前端知识点：Intl对象 和 toLocaleString的方法。\n5、交换两个整数 let a = 3,b = 4 变成 a = 4, b = 3\n5.1 普通版 首先最常规的办法，引入一个 temp 中间变量\nlet a = 3,b = 4 let temp = a a = b b = temp console.log(a, b) 优点：一眼能看懂就是最好的优点 缺点：硬说缺点就是引入了一个多余的变量\n5.2 进阶版 在不引入中间变量的情况下也能交互两个变量\nlet a = 3,b = 4 a += b b = a - b a -= b console.log(a, b) 优点：比起楼上那种没有引入多余的变量，比上面那一种稍微巧妙一点 缺点：当然缺点也很明显，整型数据溢出，比如说对于32位字符最大表示有符号数字是2147483647，也就是Math.pow(2,31)-1，如果是2147483645和2147483646交换就失败了。\n5.3 终极版 利用一个数异或本身等于０和异或运算符合交换率。\nlet a = 3,b = 4 a ^= b b ^= a a ^= b console.log(a, b) 下面用竖式进行简单说明：(10进制化为二进制)\n a = 011 (^) b = 100 则 a = 111(a ^ b的结果赋值给a，a已变成了7) (^) b = 100 则 b = 011(b^a的结果赋给b，b已经变成了3) (^) a = 111 则 a = 100(a^b的结果赋给a，a已经变成了4) 从上面的竖式可以清楚的看到利用异或运算实现两个值交换的基本过程。\n下面从深层次剖析一下：\n 1.对于开始的两个赋值语句，a = a ^ b，b = b ^ a，相当于b = b ^ (a ^ b) = a ^ b ^ b，而b ^ b 显然等于0。因此b = a ^ 0，显然结果为a。 \\2. 同理可以分析第三个赋值语句，a = a ^ b = (a ^ b) ^ a = b\n 注：\n ^ 即”异或“运算符。   它的意思是判断两个相应的位值是否为”异“，为”异\u0026quot;(值不同)就取真（1）;否则为假（0）。\n  ^ 运算符的特点是与0异或，保持原值；与本身异或，结果为0。  优点：不存在引入中间变量，不存在整数溢出 缺点：前端对位操作这一块可能了解不深，不容易理解\n5.4 究极版 熟悉 ES6 语法的人当然不会对解构陌生\nvar a = 3,b = 4; [b, a] = [a, b] 其中的解构的原理，我暂时还没读过 ES6的规范，不知道具体的细则，不过我们可以看看 babel 是自己编译的，我们可以看出点门路。\n哈哈，简单粗暴，不知道有没有按照 ES 的规范，其实可以扒一扒 v8的源码，chrome 已经实现这种解构用法。\n\n这个例子和前面的例子编写风格有何不同，你如果细心的话就会发现这两行代码多了一个分号，对于我这种编码不写分号的洁癖者，为什么加一个分号在这里，其实是有原因的，这里就简单普及一下，建议大家还是写代码写上分号。\n5.4 ECMAScript 自动分号;插入(作为补充，防止大家以后踩坑) 尽管 JavaScript 有 C 的代码风格，但是它不强制要求在代码中使用分号，实际上可以省略它们。\nJavaScript 不是一个没有分号的语言，恰恰相反上它需要分号来就解析源代码。 因此 JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会自动在源代码中插入分号。\n5.4.1例子 var foo = function() { } // 解析错误，分号丢失 test() 自动插入分号，解析器重新解析。\nvar foo = function() { }; // 没有错误，解析继续 test() 5.4.2工作原理 下面的代码没有分号，因此解析器需要自己判断需要在哪些地方插入分号。\n(function(window, undefined) { function test(options) { log(\u0026#39;testing!\u0026#39;) (options.list || []).forEach(function(i) { }) options.value.test( \u0026#39;long string to pass here\u0026#39;, \u0026#39;and another long string to pass\u0026#39; ) return { foo: function() {} } } window.test = test })(window) (function(window) { window.someLibrary = {} })(window) 下面是解析器\u0026quot;猜测\u0026quot;的结果。\n(function(window, undefined) { function test(options) { // 没有插入分号，两行被合并为一行 log(\u0026#39;testing!\u0026#39;)(options.list || []).forEach(function(i) { }); // \u0026lt;- 插入分号 options.value.test( \u0026#39;long string to pass here\u0026#39;, \u0026#39;and another long string to pass\u0026#39; ); // \u0026lt;- 插入分号 return; // \u0026lt;- 插入分号, 改变了 return 表达式的行为 { // 作为一个代码段处理 foo: function() {} }; // \u0026lt;- 插入分号 } window.test = test; // \u0026lt;- 插入分号 // 两行又被合并了 })(window)(function(window) { window.someLibrary = {}; // \u0026lt;- 插入分号 })(window); //\u0026lt;- 插入分号 解析器显著改变了上面代码的行为，在另外一些情况下也会做出错误的处理。\n5.4.3 ECMAScript对自动分号插入的规则 我们翻到7.9章节，看看其中插入分号的机制和原理，清楚只写以后就可以尽量以后少踩坑\n必须用分号终止某些 ECMAScript 语句 ( 空语句 , 变量声明语句 , 表达式语句 , do-while 语句 , continue 语句 , break 语句 , return 语句 ,throw 语句 )。这些分号总是明确的显示在源文本里。然而，为了方便起见，某些情况下这些分号可以在源文本里省略。描述这种情况会说：这种情况下给源代码的 token 流自动插入分号。\u2028 \n还是比较抽象，看不太懂是不是，不要紧，我们看看实际例子，总结出几个规律就行，我们先不看抽象的，看着头晕，看看具体的总结说明， 化抽象为具体 。\n首先这些规则是基于两点：\n 以换行为基础； 解析器会尽量将新行并入当前行，当且仅当符合ASI规则时才会将新行视为独立的语句。  5.4.3.1 ASI的规则 1. 新行并入当前行将构成非法语句，自动插入分号。\nif(1 \u0026lt; 10) a = 1 console.log(a) // 等价于 if(1 \u0026lt; 10) a = 1; console.log(a); 2. 在continue,return,break,throw后自动插入分号\nreturn {a: 1} // 等价于 return; {a: 1}; 3. ++、\u0026ndash;后缀表达式作为新行的开始，在行首自动插入分号\na ++ c // 等价于 a; ++c; 4. 代码块的最后一个语句会自动插入分号\nfunction(){ a = 1 } // 等价于 function(){ a = 1; } 5.4.3.2 No ASI的规则 1. 新行以 ( 开始\nvar a = 1 var b = a (a+b).toString() // 会被解析为以a+b为入参调用函数a，然后调用函数返回值的toString函数 var a = 1 var b =a(a+b).toString() 2. 新行以 [ 开始\nvar a = [\u0026#39;a1\u0026#39;, \u0026#39;a2\u0026#39;] var b = a [0,1].slice(1) // 会被解析先获取a[1]，然后调用a[1].slice(1)。 // 由于逗号位于[]内，且不被解析为数组字面量，而被解析为运算符，而逗号运算符会先执 行左侧表达式，然后执行右侧表达式并且以右侧表达式的计算结果作为返回值 var a = [\u0026#39;a1\u0026#39;, \u0026#39;a2\u0026#39;] var b = a[0,1].slice(1) 3. 新行以 / 开始\nvar a = 1 var b = a /test/.test(b) // /会被解析为整除运算符，而不是正则表达式字面量的起始符号。浏览器中会报test前多了个.号 var a = 1 var b = a / test / .test(b) 4. 新行以 + 、 - 、 % 和 * 开始\nvar a = 2 var b = a +a // 会解析如下格式 var a = 2 var b = a + a 5. 新行以 , 或 . 开始\nvar a = 2 var b = a .toString() console.log(typeof b) // 会解析为 var a = 2 var b = a.toString() console.log(typeof b) 到这里我们已经对ASI的规则有一定的了解了，另外还有一样有趣的事情，就是“空语句”。\n// 三个空语句 ;;; // 只有if条件语句，语句块为空语句。 // 可实现unless条件语句的效果 if(1\u0026gt;2);else console.log(\u0026#39;2 is greater than 1 always!\u0026#39;); // 只有while条件语句，循环体为空语句。 var a = 1 while(++a \u0026lt; 100); 5.4.4 结论 建议绝对不要省略分号，同时也提倡将花括号和相应的表达式放在一行， 对于只有一行代码的 if 或者 else 表达式，也不应该省略花括号。 这些良好的编程习惯不仅可以提到代码的一致性，而且可以防止解析器改变代码行为的错误处理。 关于JavaScript 语句后应该加分号么？(点我查看)我们可以看看知乎上大牛们对着个问题的看法。\n你可能不知道的前端知识点：原来 JavaScript 还有位操作以及分号的使用细则\n6、将 argruments 对象(类数组)转换成数组 {0:1,1:2,2:3,length:3}这种形式的就属于类数组，就是按照数组下标排序的对象，还有一个 length属性，有时候我们需要这种对象能调用数组下的一个方法，这时候就需要把把类数组转化成真正的数组。\n6.1 普通版 var makeArray = function(array) { var ret = [] if (array != null) { var i = array.length if (i == null || typeof array === \u0026#34;string\u0026#34;) ret[0] = array else while (i) ret[--i] = array[i]; } return ret } makeArray({0:1,1:2,2:3,length:3}) //[1,2,3] 优点：通用版本，没有任何兼容性问题 缺点：太普通\n6.2 进阶版 var arr = Array.prototype.slice.call(arguments); 这种应该是大家用过最常用的方法，至于为什么可以这么用，很多人估计也是一知半解，反正我看见大家这么用我也这么用，要搞清为什么里面的原因，我们还是从规范和源码说起。\n照着规范的流程，自己看看推演一下就明白了： 英文版15.4.4.10 Array.prototype.slice (start, end)  中文版15.4.4.10 Array.prototype.slice (start, end)  如果你想知道 JavaScript 的 sort 排序的机制，到底是哪种排序好，用的哪种，也可以从规范看出端倪。\n在官方的解释中，如[mdn]\n The slice() method returns a shallow copy of a portion of an array into a new array object.\n 简单的说就是根据参数，返回数组的一部分的 copy。所以了解其内部实现才能确定它是如何工作的。所以查看 V8 源码中的 Array.js 可以看到如下的代码：\n方法 ArraySlice，源码地址，第 660 行,直接添加到 Array.prototype 上的“入口”，内部经过参数、类型等等的判断处理，分支为 SparseSlice 和 SimpleSlice 处理。\nslice.call 的作用原理就是，利用 call，将 slice 的方法作用于 arrayLike，slice 的两个参数为空，slice 内部解析使得 arguments.lengt 等于0的时候 相当于处理 slice(0) ： 即选择整个数组，slice 方法内部没有强制判断必须是 Array 类型，slice 返回的是新建的数组（使用循环取值）”，所以这样就实现了类数组到数组的转化，call 这个神奇的方法、slice 的处理缺一不可。\n直接看 slice 怎么实现的吧。其实就是将 array-like 对象通过下标操作放进了新的 Array 里面：\n// This will work for genuine arrays, array-like objects, // NamedNodeMap (attributes, entities, notations), // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes), // and will not fail on other DOM objects (as do DOM elements in IE \u0026lt; 9) Array.prototype.slice = function(begin, end) { // IE \u0026lt; 9 gets unhappy with an undefined end argument end = (typeof end !== \u0026#39;undefined\u0026#39;) ? end : this.length; // For native Array objects, we use the native slice function if (Object.prototype.toString.call(this) === \u0026#39;[object Array]\u0026#39;){ return _slice.call(this, begin, end); } // For array like object we handle it ourselves. var i, cloned = [], size, len = this.length; // Handle negative value for \u0026#34;begin\u0026#34; var start = begin || 0; start = (start \u0026gt;= 0) ? start : Math.max(0, len + start); // Handle negative value for \u0026#34;end\u0026#34; var upTo = (typeof end == \u0026#39;number\u0026#39;) ? Math.min(end, len) : len; if (end \u0026lt; 0) { upTo = len + end; } // Actual expected size of the slice size = upTo - start; if (size \u0026gt; 0) { cloned = new Array(size); if (this.charAt) { for (i = 0; i \u0026lt; size; i++) { cloned[i] = this.charAt(start + i); } } else { for (i = 0; i \u0026lt; size; i++) { cloned[i] = this[start + i]; } } } return cloned; }; 优点：最常用的版本，兼容性较强 缺点：ie 低版本，无法处理 dom 集合的 slice call 转数组。（虽然具有数值键值、length 符合ArrayLike 的定义，却报错）搜索资料得到 ：因为 ie 下的 dom 对象是以 com 对象的形式实现的，js 对象与com对象不能进行转换 。\n6.3 ES6 版本 使用 Array.from, 值需要对象有 length 属性, 就可以转换成数组\nvar arr = Array.from(arguments); 扩展运算符\nvar args = [...arguments]; ES6 中的扩展运算符\u0026hellip;也能将某些数据结构转换成数组，这种数据结构必须有便利器接口。 优点：直接使用内置 API，简单易维护 缺点：兼容性，使用 babel 的 profill 转化可能使代码变多，文件包变大\n你可能不知道的前端知识点：slice 方法的具体原理\n7、数字取整 2.33333 =\u0026gt; 2 7.1 普通版 const a = parseInt(2.33333) parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。这个估计是直接取整最常用的方法了。 更多关于 parseInt() 函数可以查看 MDN 文档\n7.2 进阶版 const a = Math.trunc(2.33333) Math.trunc() 方法会将数字的小数部分去掉，只保留整数部分。 特别要注意的是：Internet Explorer 不支持这个方法，不过写个 Polyfill 也很简单：\nMath.trunc = Math.trunc || function(x) { if (isNaN(x)) { return NaN; } if (x \u0026gt; 0) { return Math.floor(x); } return Math.ceil(x); }; 数学的事情还是用数学方法来处理比较好。\n7.3 黑科技版 7.3.1 ~~number 双波浪线 ~~ 操作符也被称为“双按位非”操作符。你通常可以使用它作为代替 Math.trunc() 的更快的方法。\nconsole.log(~~47.11) // -\u0026gt; 47 console.log(~~1.9999) // -\u0026gt; 1 console.log(~~3) // -\u0026gt; 3 console.log(~~[]) // -\u0026gt; 0 console.log(~~NaN) // -\u0026gt; 0 console.log(~~null) // -\u0026gt; 0 失败时返回0,这可能在解决 Math.trunc() 转换错误返回 NaN 时是一个很好的替代。 但是当数字范围超出 ±2^31−1 即：2147483647 时，异常就出现了：\n// 异常情况 console.log(~~2147493647.123) // -\u0026gt; -2147473649 🙁 7.3.2 number | 0 | (按位或) 对每一对比特位执行或（OR）操作。\nconsole.log(20.15|0); // -\u0026gt; 20 console.log((-20.15)|0); // -\u0026gt; -20 console.log(3000000000.15|0); // -\u0026gt; -1294967296 🙁 7.3.3 number ^ 0 ^ (按位异或)，对每一对比特位执行异或（XOR）操作。\nconsole.log(20.15^0); // -\u0026gt; 20 console.log((-20.15)^0); // -\u0026gt; -20 console.log(3000000000.15^0); // -\u0026gt; -1294967296 🙁 7.3.4 number \u0026laquo; 0 \u0026laquo; (左移) 操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。\nconsole.log(20.15 \u0026lt; \u0026lt; 0); // -\u0026gt; 20 console.log((-20.15) \u0026lt; \u0026lt; 0); //-20 console.log(3000000000.15 \u0026lt;\u0026lt; 0); // -\u0026gt; -1294967296 🙁 上面这些按位运算符方法执行很快，当你执行数百万这样的操作非常适用，速度明显优于其他方法。但是代码的可读性比较差。还有一个特别要注意的地方，处理比较大的数字时（当数字范围超出 ±2^31−1 即：2147483647），会有一些异常情况。使用的时候明确的检查输入数值的范围。\n8、数组求和 8.1 普通版 let arr = [1, 2, 3, 4, 5] function sum(arr){ let x = 0 for(let i = 0; i \u0026lt; arr.length; i++){ x += arr[i] } return x } sum(arr) // 15 优点：通俗易懂，简单粗暴 缺点：没有亮点，太通俗\n8.2 优雅版 let arr = [1, 2, 3, 4, 5] function sum(arr) { return arr.reduce((a, b) =\u0026gt; a + b) } sum(arr) //15 优点：简单明了，数组迭代器方式清晰直观 缺点：不兼容 IE 9以下浏览器\n8.3 终极版 let arr = [1, 2, 3, 4, 5] function sum(arr) { return eval(arr.join(\u0026#34;+\u0026#34;)) } sum(arr) //15 优点：让人一时看不懂的就是\u0026quot;好方法\u0026quot;。 缺点：\n eval 不容易调试。用 chromeDev 等调试工具无法打断点调试，所以麻烦的东西也是不推荐使用的…\n  性能问题，在旧的浏览器中如果你使用了eval，性能会下降10倍。在现代浏览器中有两种编译模式：fast path和slow path。fast path是编译那些稳定和可预测（stable and predictable）的代码。而明显的，eval 不可预测，所以将会使用 slow path ，所以会慢。\n 更多关于 eval 的探讨可以关注这篇文章: JavaScript 为什么不推荐使用 eval？\n你可能不知道的前端知识点：eval的使用细则\n最后 祝大家圣诞快乐🎄，欢迎补充和交流。   \n","permalink":"https://yzqtpl.github.io/hugo-blog/post/javascript-%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8C%85%E5%90%AB%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9-/","summary":"前端 标签： 干货\nJavaScript 优雅的实现方式包含你可能不知道的知识点 有些东西很好用，但是你未必知道；有些东西你可能用过，但是你未必知道原理。\n实现一个目的有多种途径，俗话说，条条大路通罗马。很多内容来自平时的一些收集以及过往博客文章底下的精彩评论，收集整理拓展一波，发散一下大家的思维以及拓展一下知识面。\n茴字有四种写法，233333\u0026hellip;， 文末有彩蛋有惊喜。\n1、简短优雅地实现 sleep 函数 很多语言都有 sleep 函数，显然 js 没有，那么如何能简短优雅地实现这个方法？\n1.1 普通版 function sleep(sleepTime) { \tfor(var start = +new Dat e; +new Date - start \u0026lt;= sleepTime;) {} } var t1 = +new Date() sleep(3000) var t2 = +new Date() console.log(t2 - t1) 优点：简单粗暴，通俗易懂。 缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升，无论你的服务器 CPU 有多么 Niubility。\n1.2 Promise 版本 function sleep(time) {  return new Promise(resolve =\u0026gt; setTimeout(resolve, time)) }  const t1 = +new Date() sleep(3000).","title":"JavaScript 优雅的实现方式包含你可能不知道的知识点"},{"content":"Eclipse国内下载升级方法 我们在国内从官网下载Eclipse以及插件非常慢，那么，有没有方法变快呢？\n有，那就是使用国内的公开镜像源替换官方源。\n1 下载Eclipse 首先，我们看一个链接地址：\nhttp://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/juno/SR1/eclipse-jee-juno-SR1-win32.zip\n其中， http://mirror.bit.edu.cn 代表一个国内的镜像源，后面的路径基本是固定的，所以，如果需要下载一个新的版本时，可以到：\nhttp://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/\n路径下去找时间戳最新的那个文件夹，然后，去下载最新的版本。\n常用的几个速度很快的源：\n中国科学技术大学(5.6MB/s) http://mirrors.ustc.edu.cn/eclipse/\n北京理工大学（600KB/s） http://mirror.bit.edu.cn/eclipse/\n大连东软信息学院(400KB/s) http://mirrors.neusoft.edu.cn/eclipse/\n2 安装插件 同样，需要把里面的源改为速度最快的源：\n help -\u0026gt; Install New Software… -\u0026gt; Available Software Sites\n 把 http://download.eclipse.org/ 替换为 http://mirrors.ustc.edu.cn/eclipse 。\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/eclipse%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%8D%87%E7%BA%A7%E6%96%B9%E6%B3%95/","summary":"Eclipse国内下载升级方法 我们在国内从官网下载Eclipse以及插件非常慢，那么，有没有方法变快呢？\n有，那就是使用国内的公开镜像源替换官方源。\n1 下载Eclipse 首先，我们看一个链接地址：\nhttp://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/juno/SR1/eclipse-jee-juno-SR1-win32.zip\n其中， http://mirror.bit.edu.cn 代表一个国内的镜像源，后面的路径基本是固定的，所以，如果需要下载一个新的版本时，可以到：\nhttp://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/\n路径下去找时间戳最新的那个文件夹，然后，去下载最新的版本。\n常用的几个速度很快的源：\n中国科学技术大学(5.6MB/s) http://mirrors.ustc.edu.cn/eclipse/\n北京理工大学（600KB/s） http://mirror.bit.edu.cn/eclipse/\n大连东软信息学院(400KB/s) http://mirrors.neusoft.edu.cn/eclipse/\n2 安装插件 同样，需要把里面的源改为速度最快的源：\n help -\u0026gt; Install New Software… -\u0026gt; Available Software Sites\n 把 http://download.eclipse.org/ 替换为 http://mirrors.ustc.edu.cn/eclipse 。","title":""},{"content":"Javascript中最常用的55个经典技巧 1. oncontextmenu=\u0026#34;window.event.returnValue=false\u0026#34; 将彻底屏蔽鼠标右键 \u0026lt;table border oncontextmenu=return(false)\u0026gt;\u0026lt;td\u0026gt;no\u0026lt;/table\u0026gt; 可用于Table 2. \u0026lt;body onselectstart=\u0026#34;return false\u0026#34;\u0026gt; 取消选取、防止复制 3. onpaste=\u0026#34;return false\u0026#34; 不准粘贴 4. oncopy=\u0026#34;return false;\u0026#34; oncut=\u0026#34;return false;\u0026#34; 防止复制 5. \u0026lt;link rel=\u0026#34;Shortcut Icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; IE地址栏前换成自己的图标 6. \u0026lt;link rel=\u0026#34;Bookmark\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; 可以在收藏夹中显示出你的图标 7. \u0026lt;input style=\u0026#34;ime-mode:disabled\u0026#34;\u0026gt; 关闭输入法 8. 永远都会带着框架 \u0026lt;script language=\u0026#34;JavaScript\u0026#34;\u0026gt;\u0026lt;!-- if (window == top)top.location.href = \u0026#34;frames.htm\u0026#34;; //frames.htm为框架网页 // --\u0026gt;\u0026lt;/script\u0026gt; 9. 防止被人frame \u0026lt;SCRIPT LANGUAGE=JAVASCRIPT\u0026gt;\u0026lt;!-- if (top.location != self.location)top.location=self.location; // --\u0026gt;\u0026lt;/SCRIPT\u0026gt; 10. 网页将不能被另存为 \u0026lt;noscript\u0026gt;\u0026lt;*** src=\u0026#34;/*.html\u0026gt;\u0026#34;;\u0026lt;/***\u0026gt;\u0026lt;/noscript\u0026gt; 11. \u0026lt;input type=button value=\u0026#34;/查看网页源代码 onclick=\u0026#34;window.location = \u0026#34;view-source:\u0026#34;+ \u0026#34;http://www.pconline.com.cn\u0026#34;\u0026#34;\u0026gt; 12.删除时确认 \u0026lt;a href=\u0026#34;\u0026#34;javascript :if(confirm(\u0026#34;确实要删除吗?\u0026#34;))location=\u0026#34;boos.asp?\u0026amp;areyou=删除\u0026amp;page=1\u0026#34;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt; 13. 取得控件的绝对位置 //Javascript \u0026lt;script language=\u0026#34;Javascript\u0026#34;\u0026gt; function getIE(e){ var t=e.offsetTop; var l=e.offsetLeft; while(e=e.offsetParent){ t+=e.offsetTop; l+=e.offsetLeft; } alert(\u0026#34;top=\u0026#34;+t+\u0026#34;/nleft=\u0026#34;+l); } \u0026lt;/script\u0026gt; //VBScript \u0026lt;script language=\u0026#34;VBScript\u0026#34;\u0026gt;\u0026lt;!-- function getIE() dim t,l,a,b set a=document.all.img1 t=document.all.img1.offsetTop l=document.all.img1.offsetLeft while a.tagName\u0026lt;\u0026gt;\u0026#34;BODY\u0026#34; set a = a.offsetParent t=t+a.offsetTop l=l+a.offsetLeft wend msgbox \u0026#34;top=\u0026#34;\u0026amp;t\u0026amp;chr(13)\u0026amp;\u0026#34;left=\u0026#34;\u0026amp;l,64,\u0026#34;得到控件的位置\u0026#34; end function --\u0026gt;\u0026lt;/script\u0026gt; 14. 光标是停在文本框文字的最后 \u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; function cc() { var e = event.srcElement; var r =e.createTextRange(); r.moveStart(\u0026#34;character\u0026#34;,e.value.length); r.collapse(true); r.select(); } \u0026lt;/script\u0026gt; \u0026lt;input type=text name=text1 value=\u0026#34;123\u0026#34; onfocus=\u0026#34;cc()\u0026#34;\u0026gt; 15. 判断上一页的来源 javascript : document.referrer 16. 最小化、最大化、关闭窗口 \u0026lt;object id=hh1 classid=\u0026#34;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;Command\u0026#34; value=\u0026#34;Minimize\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; \u0026lt;object id=hh2 classid=\u0026#34;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;Command\u0026#34; value=\u0026#34;Maximize\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; \u0026lt;OBJECT id=hh3 classid=\u0026#34;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\u0026#34;\u0026gt; \u0026lt;PARAM NAME=\u0026#34;Command\u0026#34; value=\u0026#34;/Close\u0026#34;\u0026gt;\u0026lt;/OBJECT\u0026gt; \u0026lt;input type=button value=\u0026#34;/最小化 onclick=hh1.Click()\u0026gt; \u0026lt;input type=button value=\u0026#34;/blog/最大化 onclick=hh2.Click()\u0026gt; \u0026lt;input type=button value=关闭 onclick=hh3.Click()\u0026gt; 本例适用于IE 17.屏蔽功能键Shift,Alt,Ctrl \u0026lt;script\u0026gt; function look(){ if(event.shiftKey) alert(\u0026#34;禁止按Shift键!\u0026#34;); //可以换成ALT　CTRL } document.onkeydown=look; \u0026lt;/script\u0026gt; 18. 网页不会被缓存 \u0026lt;META HTTP-EQUIV=\u0026#34;pragma\u0026#34; CONTENT=\u0026#34;no-cache\u0026#34;\u0026gt; \u0026lt;META HTTP-EQUIV=\u0026#34;Cache-Control\u0026#34; CONTENT=\u0026#34;no-cache, must-revalidate\u0026#34;\u0026gt; \u0026lt;META HTTP-EQUIV=\u0026#34;expires\u0026#34; CONTENT=\u0026#34;Wed, 26 Feb 1997 08:21:57 GMT\u0026#34;\u0026gt; 或者\u0026lt;META HTTP-EQUIV=\u0026#34;expires\u0026#34; CONTENT=\u0026#34;0\u0026#34;\u0026gt; 19.怎样让表单没有凹凸感？ \u0026lt;input type=text style=\u0026#34;\u0026#34;\u0026#34;border:1 solid #000000\u0026#34;\u0026gt; 或 \u0026lt;input type=text style=\u0026#34;border-left:none; border-right:none; border-top:none; border-bottom: 1 solid #000000\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; 20.\u0026lt;div\u0026gt;\u0026lt;span\u0026gt;\u0026amp;\u0026lt;layer\u0026gt;的区别？ \u0026lt;div\u0026gt;(division)用来定义大段的页面元素，会产生转行 \u0026lt;span\u0026gt;用来定义同一行内的元素，跟\u0026lt;div\u0026gt;的唯一区别是不产生转行 \u0026lt;layer\u0026gt;是ns的标记，ie不支持，相当于\u0026lt;div\u0026gt; 21.让弹出窗口总是在最上面: \u0026lt;body onblur=\u0026#34;this.focus();\u0026#34;\u0026gt; 22.不要滚动条? 让竖条没有: \u0026lt;body style=\u0026#34;overflow:scroll;overflow-y:hidden\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 让横条没有: \u0026lt;body style=\u0026#34;overflow:scroll;overflow-x:hidden\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 两个都去掉？更简单了 \u0026lt;body scroll=\u0026#34;no\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 23.怎样去掉图片链接点击后，图片周围的虚线？ \u0026lt;a href=\u0026#34;#\u0026#34; onFocus=\u0026#34;this.blur()\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/logo.jpg\u0026#34; border=0\u0026gt;\u0026lt;/a\u0026gt; 24.电子邮件处理提交表单 \u0026lt;form name=\u0026#34;form1\u0026#34; method=\u0026#34;post\u0026#34; action=mailto:****@***.com enctype=\u0026#34;text/plain\u0026#34;\u0026gt; \u0026lt;input type=submit\u0026gt; \u0026lt;/form\u0026gt; 25.在打开的子窗口刷新父窗口的代码里如何写？ window.opener.location.reload() 26.如何设定打开页面的大小 \u0026lt;body onload=\u0026#34;top.resizeTo(300,200);\u0026#34;\u0026gt; 打开页面的位置\u0026lt;body onload=\u0026#34;top.moveBy(300,200);\u0026#34;\u0026gt; 27.在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动 \u0026lt;STYLE\u0026gt; body {background-image:url(/logo.gif); background-repeat:no-repeat; background-position:center;background-attachment: fixed} \u0026lt;/STYLE\u0026gt; 28. 检查一段字符串是否全由数字组成 \u0026lt;script language=\u0026#34;Javascript\u0026#34;\u0026gt;\u0026lt;!-- function checkNum(str){return str.match(//D/)==null} alert(checkNum(\u0026#34;1232142141\u0026#34;)) alert(checkNum(\u0026#34;123214214a1\u0026#34;)) // --\u0026gt;\u0026lt;/script\u0026gt; 29. 获得一个窗口的大小 document.body.clientWidth; document.body.clientHeight 30. 怎么判断是否是字符 if (/[^/x00-/xff]/g.test(s)) alert(\u0026#34;含有汉字\u0026#34;); else alert(\u0026#34;全是字符\u0026#34;); 31.TEXTAREA自适应文字行数的多少 \u0026lt;textarea rows=1 name=s1 cols=27 onpropertychange =\u0026#34;this.style.posHeight=this.scrollHeight\u0026#34;\u0026gt; \u0026lt;/textarea\u0026gt; 32. 日期减去天数等于第二个日期 \u0026lt;script language=Javascript\u0026gt; function cc(dd,dadd) { //可以加上错误处理 var a = new Date(dd) a = a.valueOf() a = a - dadd * 24 * 60 * 60 * 1000 a = new Date(a) alert(a.getFullYear() + \u0026#34;年\u0026#34; + (a.getMonth() + 1) + \u0026#34;月\u0026#34; + a.getDate() + \u0026#34;日\u0026#34;) } cc(\u0026#34;12/23/2002\u0026#34;,2) \u0026lt;/script\u0026gt; 33. 选择了哪一个Radio \u0026lt;HTML\u0026gt;\u0026lt;script language=\u0026#34;vbscript\u0026#34;\u0026gt; function checkme() for each ob in radio1 if ob.checked then window.alert ob.value next end function \u0026lt;/script\u0026gt;\u0026lt;BODY\u0026gt; \u0026lt;INPUT name=\u0026#34;radio1\u0026#34; type=\u0026#34;radio\u0026#34; value=\u0026#34;/style\u0026#34; checked\u0026gt;Style \u0026lt;INPUT name=\u0026#34;radio1\u0026#34; type=\u0026#34;radio\u0026#34; value=\u0026#34;/blog/barcode\u0026#34;\u0026gt;Barcode \u0026lt;INPUT type=\u0026#34;button\u0026#34; value=\u0026#34;check\u0026#34; onclick=\u0026#34;checkme()\u0026#34;\u0026gt; \u0026lt;/BODY\u0026gt;\u0026lt;/HTML\u0026gt; 34.脚本永不出错 \u0026lt;SCRIPT LANGUAGE=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;!-- Hide function killErrors() { return true; } window.onerror = killErrors; // --\u0026gt; \u0026lt;/SCRIPT\u0026gt; 35.ENTER键可以让光标移到下一个输入框 \u0026lt;input onkeydown=\u0026#34;if(event.keyCode==13)event.keyCode=9\u0026#34;\u0026gt; 36. 检测某个网站的链接速度： 把如下代码加入\u0026lt;body\u0026gt;区域中: \u0026lt;script language=Javascript\u0026gt; tim=1 setInterval(\u0026#34;tim++\u0026#34;,100) b=1 var autourl=new Array() autourl[1]=1000){this.resized=true;this.style.width=1000;}\u0026#34; align=absMiddle border=0\u0026gt;www.njcatv.net\u0026#34; autourl[2]=\u0026#34;javacool.3322.net\u0026#34; autourl[3]=1000){this.resized=true;this.style.width=1000;}\u0026#34; align=absMiddle border=0\u0026gt;www.sina.com.cn\u0026#34; autourl[4]=\u0026#34;www.nuaa.edu.cn\u0026#34; autourl[5]=1000){this.resized=true;this.style.width=1000;}\u0026#34; align=absMiddle border=0\u0026gt;www.cctv.com\u0026#34; function butt(){ ***(\u0026#34;\u0026lt;form name=autof\u0026gt;\u0026#34;) for(var i=1;i\u0026lt;autourl.length;i++) ***(\u0026#34;\u0026lt;input type=text name=txt\u0026#34;+i+\u0026#34; size=10 value=\u0026#34;/测试中……\u0026gt; =》\u0026lt;input type=text name=url\u0026#34;+i+\u0026#34; size=40\u0026gt; =》\u0026lt;input type=button value=\u0026#34;/blog/GO onclick=window.open(this.form.url\u0026#34;+i+\u0026#34;.value)\u0026gt;\u0026lt;br\u0026gt;\u0026#34;) ***(\u0026#34;\u0026lt;input type=submit value=刷新\u0026gt;\u0026lt;/form\u0026gt;\u0026#34;) } butt() function auto(url){ document.forms[0][\u0026#34;url\u0026#34;+b].value=url if(tim\u0026gt;200) {document.forms[0][\u0026#34;txt\u0026#34;+b].value=\u0026#34;/链接超时\u0026#34;} else {document.forms[0][\u0026#34;txt\u0026#34;+b].value=\u0026#34;/blog/时间\u0026#34;+tim/10+\u0026#34;秒\u0026#34;} b++ } function run(){for(var i=1;i\u0026lt;autourl.length;i++)***(\u0026#34;\u0026lt;img src=http://\u0026#34;+autourl+\u0026#34;/\u0026#34;+Math.random()+\u0026#34; width=1 height=1 onerror=auto(\u0026#34;http://\u0026#34;+autourl+\u0026#34;\u0026#34;)\u0026gt;\u0026#34;)} run()\u0026lt;/script\u0026gt; 37. 各种样式的光标 auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I形光标 vertical-text ：水平I形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize 38.页面进入和退出的特效 进入页面\u0026lt;meta http-equiv=\u0026#34;Page-Enter\u0026#34; content=\u0026#34;revealTrans(duration=x, transition=y)\u0026#34;\u0026gt; 推出页面\u0026lt;meta http-equiv=\u0026#34;Page-Exit\u0026#34; content=\u0026#34;revealTrans(duration=x, transition=y)\u0026#34;\u0026gt; 这个是页面被载入和调出时的一些特效。duration表示特效的持续时间，以秒为单位。transition表示使用哪种特效，取值为1-23: 0 矩形缩小 1 矩形扩大 2 圆形缩小 3 圆形扩大 4 下到上刷新 5 上到下刷新 6 左到右刷新 7 右到左刷新 8 竖百叶窗 9 横百叶窗 10 错位横百叶窗 11 错位竖百叶窗 12 点扩散 13 左右到中间刷新 14 中间到左右刷新 15 中间到上下 16 上下到中间 17 右下到左上 18 右上到左下 19 左上到右下 20 左下到右上 21 横条 22 竖条 23 以上22种随机选择一种 39.在规定时间内跳转 \u0026lt;META http-equiv=V=\u0026#34;REFRESH\u0026#34; content=\u0026#34;5;URL=http://www.51js.com\u0026#34;\u0026gt; 40.网页是否被检索 \u0026lt;meta name=\u0026#34;ROBOTS\u0026#34; content=\u0026#34;属性值\u0026#34;\u0026gt; 其中属性值有以下一些: 属性值为\u0026#34;all\u0026#34;: 文件将被检索，且页上链接可被查询； 属性值为\u0026#34;none\u0026#34;: 文件不被检索，而且不查询页上的链接； 属性值为\u0026#34;index\u0026#34;: 文件将被检索； 属性值为\u0026#34;follow\u0026#34;: 查询页上的链接； 属性值为\u0026#34;noindex\u0026#34;: 文件不检索，但可被查询链接； 属性值为\u0026#34;nofollow\u0026#34;: 文件不被检索，但可查询页上的链接。 41、email地址的分割 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;a href=\u0026#34;mailto:webmaster@sina.com\u0026#34;\u0026gt;webmaster@sina.com\u0026lt;/a\u0026gt; 42、流动边框效果的表格 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;SCRIPT\u0026gt; l=Array(6,7,8,9,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;) Nx=5;Ny=35 t=\u0026#34;\u0026lt;table border=0 cellspacing=0 cellpadding=0 height=\u0026#34;+((Nx+2)*16)+\u0026#34;\u0026gt;\u0026lt;tr\u0026gt;\u0026#34; for(x=Nx;x\u0026lt;Nx+Ny;x++) t+=\u0026#34;\u0026lt;td width=16 id=a_mo\u0026#34;+x+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026#34; t+=\u0026#34;\u0026lt;/tr\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td width=10 id=a_mo\u0026#34;+(Nx-1)+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026lt;td colspan=\u0026#34;+(Ny-2)+\u0026#34; rowspan=\u0026#34;+(Nx)+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026lt;td width=16 id=a_mo\u0026#34;+(Nx+Ny)+\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34; for(x=2;x\u0026lt;=Nx;x++) t+=\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;td width=16 id=a_mo\u0026#34;+(Nx-x)+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026lt;td width=16 id=a_mo\u0026#34;+(Ny+Nx+x-1)+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34; t+=\u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for(x=Ny;x\u0026gt;0;x--) t+=\u0026#34;\u0026lt;td width=16 id=a_mo\u0026#34;+(x+Nx*2+Ny-1)+\u0026#34;\u0026gt;　\u0026lt;/td\u0026gt;\u0026#34; ***(t+\u0026#34;\u0026lt;/tr\u0026gt;\u0026lt;/table\u0026gt;\u0026#34;) var N=Nx*2+Ny*2 function f1(y){ for(i=0;i\u0026lt;N;i++){ c=(i+y)%20;if(c\u0026gt;10)c=20-c document.all[\u0026#34;a_mo\u0026#34;+(i)].bgColor=\u0026#34;\u0026#34;\u0026#34;\u0026#34;#0000\u0026#34;+l[c]+l[c]+\u0026#34;\u0026#39;\u0026#34;} y++ setTimeout(\u0026#39;f1(\u0026#39;+y+\u0026#39;)\u0026#39;,\u0026#39;1\u0026#39;)} f1(1) \u0026lt;/SCRIPT\u0026gt; 43、JavaScript主页弹出窗口技巧 窗口中间弹出 \u0026lt;script\u0026gt; window.open(\u0026#34;http://www.cctv.com\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;width=400,height=240,top=\u0026#34;+(screen.availHeight-240)/2+\u0026#34;,left=\u0026#34;+(screen.availWidth-400)/2); \u0026lt;/script\u0026gt; ============ \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script language=\u0026#34;LiveScript\u0026#34;\u0026gt; function WinOpen() { msg=open(\u0026#34;\u0026#34;,\u0026#34;DisplayWindow\u0026#34;,\u0026#34;toolbar=no,directories=no,menubar=no\u0026#34;); msg.***(\u0026#34;\u0026lt;HEAD\u0026gt;\u0026lt;TITLE\u0026gt;哈 罗!\u0026lt;/TITLE\u0026gt;\u0026lt;/HEAD\u0026gt;\u0026#34;); msg.***(\u0026#34;\u0026lt;CENTER\u0026gt;\u0026lt;H1\u0026gt;酷 毙 了!\u0026lt;/H1\u0026gt;\u0026lt;h2\u0026gt;这 是\u0026lt;B\u0026gt;JavaScript\u0026lt;/B\u0026gt;所 开 的 视 窗!\u0026lt;/h2\u0026gt;\u0026lt;/CENTER\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Button1\u0026#34; value=\u0026#34;Push me\u0026#34; onclick=\u0026#34;WinOpen()\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ============== 一、在下面的代码中，你只要单击打开一个窗口，即可链接到赛迪网。而当你想关闭时，只要单击一下即可关闭刚才打开的窗口。 代码如下： \u0026lt;SCRIPT language=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;！-- function openclk() { another=open(\u0026#39;1000){this.resized=true;this.style.width=1000;}\u0026#34; align=absMiddle border=0\u0026gt;http://www.ccidnet.com\u0026#39;，\u0026#39;NewWindow\u0026#39;); } function closeclk() { another.close(); } //--\u0026gt; \u0026lt;/SCRIPT\u0026gt; \u0026lt;FORM\u0026gt; \u0026lt;INPUT TYPE=\u0026#34;BUTTON\u0026#34; NAME=\u0026#34;open\u0026#34; value=\u0026#34;/打开一个窗口\u0026#34; onClick=\u0026#34;openclk()\u0026#34;\u0026gt; \u0026lt;BR\u0026gt; \u0026lt;INPUT TYPE=\u0026#34;BUTTON\u0026#34; NAME=\u0026#34;close\u0026#34; value=\u0026#34;/blog/关闭这个窗口\u0026#34; onClick=\u0026#34;closeclk()\u0026#34;\u0026gt; \u0026lt;/FORM\u0026gt; 二、上面的代码也太静了，为何不来点动感呢？如果能给页面来个降落效果那该多好啊！ 代码如下： \u0026lt;script\u0026gt; function drop(n) { if(self.moveBy){ self.moveBy (0，-900); for(i = n; i \u0026gt; 0; i--){ self.moveBy(0，3); } for(j = 8; j \u0026gt; 0; j--){ self.moveBy(0，j); self.moveBy(j，0); self.moveBy(0，-j); self.moveBy(-j，0); } } } \u0026lt;/script\u0026gt; \u0026lt;body onLoad=\u0026#34;drop(300)\u0026#34;\u0026gt; 三、讨厌很多网站总是按照默认窗口打开，如果你能随心所欲控制打开的窗口那该多好。 代码如下: \u0026lt;SCRIPT LANGUAGE=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;！-- Begin function popupPage(l， t， w， h) { var windowprops = \u0026#34;location=no，scrollbars=no，menubars=no，toolbars=no，resizable=yes\u0026#34; + \u0026#34;，left=\u0026#34; + l + \u0026#34;，top=\u0026#34; + t + \u0026#34;，width=\u0026#34; + w + \u0026#34;，height=\u0026#34; + h; var URL = \u0026#34;http://www.80cn.com\u0026#34;; popup = window.open(URL，\u0026#34;MenuPopup\u0026#34;，windowprops); } // End --\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;form name=popupform\u0026gt; \u0026lt;pre\u0026gt; 打开页面的参数\u0026lt;br\u0026gt; 离开左边的距离: \u0026lt;input type=text name=left size=2 maxlength=4\u0026gt; pixels 离开右边的距离: \u0026lt;input type=text name=top size=2 maxlength=4\u0026gt; pixels 窗口的宽度: \u0026lt;input type=text name=width size=2 maxlength=4\u0026gt; pixels 窗口的高度: \u0026lt;input type=text name=height size=2 maxlength=4\u0026gt; pixels \u0026lt;/pre\u0026gt; \u0026lt;center\u0026gt; \u0026lt;input type=button value=\u0026#34;打开这个窗口！\u0026#34; onClick=\u0026#34;popupPage(this.form.left.value， this.form.top.value， this.form.width.value， this.form.height.value)\u0026#34;\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;你只要在相对应的对话框中输入一个数值即可，将要打开的页面的窗口控制得很好。 44、页面的打开移动 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;SCRIPT LANGUAGE=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;!-- Begin for (t = 2; t \u0026gt; 0; t--) { for (x = 20; x \u0026gt; 0; x--) { for (y = 10; y \u0026gt; 0; y--) { parent.moveBy(0,-x); } } for (x = 20; x \u0026gt; 0; x--) { for (y = 10; y \u0026gt; 0; y--) { parent.moveBy(0,x); } } for (x = 20; x \u0026gt; 0; x--) { for (y = 10; y \u0026gt; 0; y--) { parent.moveBy(x,0); } } for (x = 20; x \u0026gt; 0; x--) { for (y = 10; y \u0026gt; 0; y--) { parent.moveBy(-x,0); } } } //--\u0026gt; // End --\u0026gt; \u0026lt;/script\u0026gt; 45、显示个人客户端机器的日期和时间 \u0026lt;script language=\u0026#34;LiveScript\u0026#34;\u0026gt; \u0026lt;!-- Hiding today = new Date() ***(\u0026#34;现 在 时 间 是： \u0026#34;,today.getHours(),\u0026#34;:\u0026#34;,today.getMinutes()) ***(\u0026#34;\u0026lt;br\u0026gt;今 天 日 期 为： \u0026#34;, today.getMonth()+1,\u0026#34;/\u0026#34;,today.getDate(),\u0026#34;/\u0026#34;,today.getYear()); // end hiding contents --\u0026gt; \u0026lt;/script\u0026gt; 46、自动的为你每次产生最後修改的日期了： \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; This is a simple HTML- page. \u0026lt;br\u0026gt; Last changes: \u0026lt;script language=\u0026#34;LiveScript\u0026#34;\u0026gt; \u0026lt;!-- hide script from old browsers ***(document.lastModified) // end hiding contents --\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 47、不能为空和邮件地址的约束： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script language=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;!-- Hide function test1(form) { if (form.text1.value == \u0026#34;\u0026#34;) alert(\u0026#34;您 没 写 上 任 何 东 西， 请 再 输 入 一 次 !\u0026#34;) else { alert(\u0026#34;嗨 \u0026#34;+form.text1.value+\u0026#34;! 您 已 输 入 完 成 !\u0026#34;); } } function test2(form) { if (form.text2.value == \u0026#34;\u0026#34; || form.text2.value.indexOf(\u0026#39;@\u0026#39;, 0) == -1) alert(\u0026#34;这 不 是 正 确 的 e-mail address! 请 再 输 入 一 次 !\u0026#34;); else alert(\u0026#34;您 已 输 入 完 成 !\u0026#34;); } // --\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form name=\u0026#34;first\u0026#34;\u0026gt; Enter your name:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;text1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;button1\u0026#34; value=\u0026#34;输 入 测 试\u0026#34; onClick=\u0026#34;test1(this.form)\u0026#34;\u0026gt; \u0026lt;P\u0026gt; Enter your e-mail address:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;text2\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;button2\u0026#34; value=\u0026#34;输 入 测 试\u0026#34; onClick=\u0026#34;test2(this.form)\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 48、跑马灯 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script language=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;!-- Hide var scrtxt=\u0026#34;怎麽样 ! 很酷吧 ! 您也可以试试.\u0026#34;+\u0026#34;Here goes your message the visitors to your page will \u0026#34;+\u0026#34;look at for hours in pure fascination...\u0026#34;; var lentxt=scrtxt.length; var width=100; var pos=1-width; function scroll() { pos++; var scroller=\u0026#34;\u0026#34;; if (pos==lentxt) { pos=1-width; } if (pos\u0026lt;0) { for (var i=1; i\u0026lt;=Math.abs(pos); i++) { scroller=scroller+\u0026#34; \u0026#34;;} scroller=scroller+scrtxt.substring(0,width-i+1); } else { scroller=scroller+scrtxt.substring(pos,width+pos); } window.status = scroller; setTimeout(\u0026#34;scroll()\u0026#34;,150); } //--\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onLoad=\u0026#34;scroll();return true;\u0026#34;\u0026gt; 这里可显示您的网页 ! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 49、在网页中用按钮来控制前页，后页和主页的显示。 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;FORM NAME=\u0026#34;buttonbar\u0026#34;\u0026gt; \u0026lt;INPUT TYPE=\u0026#34;button\u0026#34; VALUE=\u0026#34;Back\u0026#34; onClick=\u0026#34;history.back()\u0026#34;\u0026gt; \u0026lt;INPUT TYPE=\u0026#34;button\u0026#34; VALUE=\u0026#34;JS- Home\u0026#34; onClick=\u0026#34;location=\u0026#39;script.html\u0026#39;\u0026#34;\u0026gt; \u0026lt;INPUT TYPE=\u0026#34;button\u0026#34; VALUE=\u0026#34;Next\u0026#34; onCLick=\u0026#34;history.forward()\u0026#34;\u0026gt; \u0026lt;/FORM\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 50、查看某网址的源代码 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;SCRIPT\u0026gt; function add() { var ress=document.forms[0].luxiaoqing.value window.location=\u0026#34;view-source:\u0026#34;+ress; } \u0026lt;/SCRIPT\u0026gt; 输入要查看源代码的URL地址: \u0026lt;FORM\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;luxiaoqing\u0026#34; size=40 value=\u0026#34;http://\u0026#34;\u0026gt;\u0026lt;/FORM\u0026gt; \u0026lt;FORM\u0026gt;\u0026lt;br\u0026gt; \u0026lt;INPUT type=\u0026#34;button\u0026#34; value=\u0026#34;查看源代码\u0026#34; onClick=add()\u0026gt; \u0026lt;/FORM\u0026gt; 51、title显示日期 把如下代码加入\u0026lt;body\u0026gt;区域中: \u0026lt;script language=\u0026#34;JavaScript1.2\u0026#34;\u0026gt; \u0026lt;!--hide var isnMonth = new Array(\u0026#34;1月\u0026#34;,\u0026#34;2月\u0026#34;,\u0026#34;3月\u0026#34;,\u0026#34;4月\u0026#34;,\u0026#34;5月\u0026#34;,\u0026#34;6月\u0026#34;,\u0026#34;7月\u0026#34;,\u0026#34;8月\u0026#34;,\u0026#34;9月\u0026#34;,\u0026#34;10月\u0026#34;,\u0026#34;11月\u0026#34;,\u0026#34;12月\u0026#34;); var isnDay = new Array(\u0026#34;星期日\u0026#34;,\u0026#34;星期一\u0026#34;,\u0026#34;星期二\u0026#34;,\u0026#34;星期三\u0026#34;,\u0026#34;星期四\u0026#34;,\u0026#34;星期五\u0026#34;,\u0026#34;星期六\u0026#34;,\u0026#34;星期日\u0026#34;); today = new Date () ; Year=today.getYear(); Date=today.getDate(); if (document.all) document.title=\u0026#34;今天是: \u0026#34;+Year+\u0026#34;年\u0026#34;+isnMonth[today.getMonth()]+Date+\u0026#34;日\u0026#34;+isnDay[today.getDay()] //--hide--\u0026gt; \u0026lt;/script\u0026gt; 52、显示所有链接 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;script language=\u0026#34;JavaScript1.2\u0026#34;\u0026gt; \u0026lt;!-- function extractlinks(){ var links=document.all.tags(\u0026#34;A\u0026#34;) var total=links.length var win2=window.open(\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;menubar,scrollbars,toolbar\u0026#34;) win2.***(\u0026#34;\u0026lt;font size=\u0026#39;2\u0026#39;\u0026gt;一共有\u0026#34;+total+\u0026#34;个连接\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt;\u0026#34;) for (i=0;i\u0026lt;total;i++){ win2.***(\u0026#34;\u0026lt;font size=\u0026#39;2\u0026#39;\u0026gt;\u0026#34;+links[i].outerHTML+\u0026#34;\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt;\u0026#34;) } } //--\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; onClick=\u0026#34;extractlinks()\u0026#34; value=\u0026#34;显示所有的连接\u0026#34;\u0026gt; 53、回车键换行 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function handleEnter (field, event) { var keyCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode; if (keyCode == 13) { var i; for (i = 0; i \u0026lt; field.form.elements.length; i++) if (field == field.form.elements[i]) break; i = (i + 1) % field.form.elements.length; field.form.elements[i].focus(); return false; } else return true; } \u0026lt;/script\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onkeypress=\u0026#34;return handleEnter(this, event)\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onkeypress=\u0026#34;return handleEnter(this, event)\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;textarea\u0026gt;回车换行 54、确认后提交 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;SCRIPT LANGUAGE=\u0026#34;JavaScript\u0026#34;\u0026gt; \u0026lt;!-- function msg(){ if (confirm(\u0026#34;你确认要提交嘛！\u0026#34;)) document.lnman.submit() } //--\u0026gt; \u0026lt;/SCRIPT\u0026gt; \u0026lt;form name=\u0026#34;lnman\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;textfield\u0026#34; value=\u0026#34;确认后提交\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;提交\u0026#34; onclick=\u0026#34;msg();\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; 55、改变表格的内容 把如下代码加入\u0026lt;body\u0026gt;区域中 \u0026lt;script ***script\u0026gt; var arr=new Array() arr[0]=\u0026#34;一一一一一\u0026#34;; arr[1]=\u0026#34;二二二二二\u0026#34;; arr[2]=\u0026#34;三三三三三\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;select onchange=\u0026#34;zz.cells[this.selectedIndex].innerHTML=arr[this.selectedIndex]\u0026#34;\u0026gt; \u0026lt;option value=a\u0026gt;改变第一格\u0026lt;/option\u0026gt; \u0026lt;option value=a\u0026gt;改变第二格\u0026lt;/option\u0026gt; \u0026lt;option value=a\u0026gt;改变第三格\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;table id=zz border=1\u0026gt; \u0026lt;tr height=20\u0026gt; \u0026lt;td width=150\u0026gt;第一格\u0026lt;/td\u0026gt; \u0026lt;td width=150\u0026gt;第二格\u0026lt;/td\u0026gt; \u0026lt;td width=150\u0026gt;第三格\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; ","permalink":"https://yzqtpl.github.io/hugo-blog/post/javascript%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8455%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8A%80%E5%B7%A7/","summary":"Javascript中最常用的55个经典技巧 1. oncontextmenu=\u0026#34;window.event.returnValue=false\u0026#34; 将彻底屏蔽鼠标右键 \u0026lt;table border oncontextmenu=return(false)\u0026gt;\u0026lt;td\u0026gt;no\u0026lt;/table\u0026gt; 可用于Table 2. \u0026lt;body onselectstart=\u0026#34;return false\u0026#34;\u0026gt; 取消选取、防止复制 3. onpaste=\u0026#34;return false\u0026#34; 不准粘贴 4. oncopy=\u0026#34;return false;\u0026#34; oncut=\u0026#34;return false;\u0026#34; 防止复制 5. \u0026lt;link rel=\u0026#34;Shortcut Icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; IE地址栏前换成自己的图标 6. \u0026lt;link rel=\u0026#34;Bookmark\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; 可以在收藏夹中显示出你的图标 7. \u0026lt;input style=\u0026#34;ime-mode:disabled\u0026#34;\u0026gt; 关闭输入法 8. 永远都会带着框架 \u0026lt;script language=\u0026#34;JavaScript\u0026#34;\u0026gt;\u0026lt;!-- if (window == top)top.location.href = \u0026#34;frames.htm\u0026#34;; //frames.htm为框架网页 // --\u0026gt;\u0026lt;/script\u0026gt; 9. 防止被人frame \u0026lt;SCRIPT LANGUAGE=JAVASCRIPT\u0026gt;\u0026lt;!-- if (top.location != self.location)top.location=self.location; // --\u0026gt;\u0026lt;/SCRIPT\u0026gt; 10. 网页将不能被另存为 \u0026lt;noscript\u0026gt;\u0026lt;*** src=\u0026#34;/*.html\u0026gt;\u0026#34;;\u0026lt;/***\u0026gt;\u0026lt;/noscript\u0026gt; 11. \u0026lt;input type=button value=\u0026#34;/查看网页源代码 onclick=\u0026#34;window.location = \u0026#34;view-source:\u0026#34;+ \u0026#34;http://www.","title":""},{"content":"java问题 注意区分\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/java%E6%8F%8F%E8%BF%B0/","summary":"java问题 注意区分","title":""},{"content":"zh-CN 多行模式，多行模式必须指定高度。\nen-US Multi lines mode.\nimport { Mention } from \u0026#39;antd\u0026#39;; const { toString } = Mention;  function onChange(editorState) {  console.log(toString(editorState)); }  ReactDOM.render(  \u0026lt;Mention  style={{ width: \u0026#39;100%\u0026#39;, height: 100 }}  onChange={onChange}  suggestions={[\u0026#39;afc163\u0026#39;, \u0026#39;benjycui\u0026#39;, \u0026#39;yiminghe\u0026#39;, \u0026#39;jljsj33\u0026#39;, \u0026#39;dqaria\u0026#39;, \u0026#39;RaoHai\u0026#39;]}  multiLines  /\u0026gt; , mountNode); ","permalink":"https://yzqtpl.github.io/hugo-blog/post/multilines/","summary":"zh-CN 多行模式，多行模式必须指定高度。\nen-US Multi lines mode.\nimport { Mention } from \u0026#39;antd\u0026#39;; const { toString } = Mention;  function onChange(editorState) {  console.log(toString(editorState)); }  ReactDOM.render(  \u0026lt;Mention  style={{ width: \u0026#39;100%\u0026#39;, height: 100 }}  onChange={onChange}  suggestions={[\u0026#39;afc163\u0026#39;, \u0026#39;benjycui\u0026#39;, \u0026#39;yiminghe\u0026#39;, \u0026#39;jljsj33\u0026#39;, \u0026#39;dqaria\u0026#39;, \u0026#39;RaoHai\u0026#39;]}  multiLines  /\u0026gt; , mountNode); ","title":""},{"content":"SSH框架整合\nSSH三大框架整合 鉴于我的MyEclipse版本是最新的,你的版本可能比较低,有问题可以问我 ## 第一步建立数据库 ,这个是比较重要的,之后的hibernate逆向工程要用到 在mysql中建立一个student数据库,并创建表login_info,student_info 创建student表(当然可以创建你自己的表,自己的字段,你喜欢就好啦)\ncreate table student.student_info ( xhao varchar(11) null, xming varchar(11) null, xbie varchar(11) null, nling int null, xyuan varchar(11) null, bji varchar(11) null, zhye varchar(11) null, dhua varchar(11) null, yxiang varchar(11) null ); 第二步创建工程 打开MyEclipse创建一个web project,当然你的可能还有一个dynamic web project,这些项目可以相互转化,你喜欢就好\n 下面是编译完成的二进制文件位置\n \u0026gt; 默认就可以,点击finish,项目创建完成 完成后的目录\n## 第三步添加ssh三大框架的依赖 ### 添加spring的依赖 选中你的工程点击菜单栏上的project,如图所示,或者右键单击菜单的configure facets (这里低版本的可能在菜单栏的MyEclipse选项下找facets有关的选项)\n下面配置的过程就按图示来即可 下图选择spring的版本,老师用的3.0,也是你喜欢就好\n配置hibernate 选中你的工程点击菜单栏上的project,像配置sping一样,或者右键单击菜单的configure facets 然后可以在src里创建student实体类的包entity或者model(为将来的逆向工程准备)也可以同时顺便创建action,service,service,impl,dao包\n逆向工程 点击切换到databaseexplorer视图\n\u0026gt; 在这里新建一个数据库连接 点击New\n这一这里的jar包驾驶你的mysql-connetor的jar包\n连接成功\n## 逆向工程 双击打开你的mysql连接,进行逆向工程\n 在你的表上右键,找到逆向工程菜单并点击\n 按图中选中的就好\n然后一路下一步,下一步\n然后切换到MyEclipse视图 看到entity包里面已经有了\n## 配置struts 选中你的工程点击菜单栏上的project,像配置sping一样,或者右键单击菜单的configure facets install struts2\n 如下图选中 core Facets spring web 后面的dwr可选可不选(ajax框架)\n  配置完了struts可以写action包里的类,也可以写service包里的类,看你的喜好了,我选择写service里的类\n package service; import java.util.List; import entity.StudentInfo; public interface QryService { public List\u0026lt;StudentInfo\u0026gt; getAll(); public boolean del(Integer num); public StudentInfo findXshxx(Integer num); public boolean update(StudentInfo xsh); public void saveStd(StudentInfo xsh); } 然后编写service的实现类\npublic class QryServiceImpl implements QryService { private StudentInfoDAO stdinfoDao; private StudentInfo stdinfo, stdinfo1; private List\u0026lt;StudentInfo\u0026gt; lst; ...... } 之后可以将老师的jsp放在webroot文件夹里面是前端页面\n最后配置action 在action包中配置相应的StudentAction类并将相应的action写入struts.xml中 ssh的配置文件application.xml web.xml都是自动生成的,几乎不用配置 下面是文件结构\n大致就像老师的ssh架构示意图 这里配好了struts,写好了前后端代码,已经配置成功了 之首就是打开tomcat服务器,不停的调试运行,最终运行失败,不过也不担心,因为老师的也不一定对\n其实上面讲的就是实验二的作业,你可以好好看一看,有问题问我,我随叫随到~\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/ssh%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","summary":"SSH框架整合\nSSH三大框架整合 鉴于我的MyEclipse版本是最新的,你的版本可能比较低,有问题可以问我 ## 第一步建立数据库 ,这个是比较重要的,之后的hibernate逆向工程要用到 在mysql中建立一个student数据库,并创建表login_info,student_info 创建student表(当然可以创建你自己的表,自己的字段,你喜欢就好啦)\ncreate table student.student_info ( xhao varchar(11) null, xming varchar(11) null, xbie varchar(11) null, nling int null, xyuan varchar(11) null, bji varchar(11) null, zhye varchar(11) null, dhua varchar(11) null, yxiang varchar(11) null ); 第二步创建工程 打开MyEclipse创建一个web project,当然你的可能还有一个dynamic web project,这些项目可以相互转化,你喜欢就好\n 下面是编译完成的二进制文件位置\n \u0026gt; 默认就可以,点击finish,项目创建完成 完成后的目录\n## 第三步添加ssh三大框架的依赖 ### 添加spring的依赖 选中你的工程点击菜单栏上的project,如图所示,或者右键单击菜单的configure facets (这里低版本的可能在菜单栏的MyEclipse选项下找facets有关的选项)\n下面配置的过程就按图示来即可 下图选择spring的版本,老师用的3.0,也是你喜欢就好\n配置hibernate 选中你的工程点击菜单栏上的project,像配置sping一样,或者右键单击菜单的configure facets 然后可以在src里创建student实体类的包entity或者model(为将来的逆向工程准备)也可以同时顺便创建action,service,service,impl,dao包\n逆向工程 点击切换到databaseexplorer视图\n\u0026gt; 在这里新建一个数据库连接 点击New\n这一这里的jar包驾驶你的mysql-connetor的jar包","title":""},{"content":"项目沟通 通过适当和及时地生成、采集、储存、处理和发布有关项目信息，确保适当的项目干系\n项目沟通管理包括为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程。\n基本原则 准确性,完整性,及时性\n沟通在管理中的作用 　知道管理沟通的重要性后，不仅仅停止在理念层面，而应落实到执行层面，必须通过内、外部沟通机制来协助执行，以执行到位，效果更好。\n　管理沟通分外部沟通和内部沟通。\n　外部沟通一是通过公共关系手段，利用大众传媒、内部刊物等途径，与客户、政府职能部门、周边社区、金融机构等，建立良好关系，争取社会各界支持，创造好的发展氛围；二是企业导入CIS企业形象识别系统，把理念系统、行为系统、视觉系统进行有效整合，进行科学合理的传播，树立良好企业形象，提高企业的知名度、美誉度、资信度，为企业腾飞和持续发展提供好的环境。\n　内部沟通一是建立健全规范公司会议系统，使公司各种指令、计划信息能上传下达，相互协调，围绕企业各项指标的完成统筹执行。通过月会、周例会、调度会、座谈会、班前班后会等形式，快速地将信息进行有效的传递，使大家按计划有条不紊进行，步调一致，方向目标明确，提高工作效率和效能，使目标完成得到保障。二是针对公司全体员工展开“合理化建议”活动，设立合理化建议箱和[合理化建议奖。无论是技术改造、成本控制、行政管理等各领域，全面展开。从为企业发展到献计献策，树立主人翁精神，获得好的效果，从经济各个角度收获很大。三是建立公司内部刊物，每月一期，发致公司各个层面，把公司生产经营动态进行有效汇总，整合公司信息，统一全体员工思想。各车间定期办黑板报、报纸专栏，丰富职业精神生活，同时也是沟通的一种形式。五是把每周五定为公司“沟通日”。公司总经理的门是敞开着的，欢迎各级层员工进来沟通谈话。无论是意见，还是建议一并笑纳，快速做出改进，了解各级层员工的需求动态，尽可能满足他们，真正实现“以人为本”，提高员工满意度，把员工当作绩效伙伴而非“打工者”雇员，形成命运共同体，而非单纯利益共同体。六是每月集中给该月生日的员工过“生日餐会”，公司给每位生日员工发生日蛋糕、聚餐的同时，送上总经理签名的生日卡，使很多员工都很感动，感到企业大家庭的温暖，更是一心一意为公司做贡献，提升对公司的忠诚度和凝聚力。还有定期举办的联欢会、运动会、表彰会、优秀员工干部旅游活动等，使大家干得起劲、玩得开心，觉得自己与公司已密不可分，人企合一，共同成长，把公司当成自己创业、施展才能的大舞台，产生良好的效果。\n如何沟通 　(一)首先让管理者意识到沟通的重要性。\n　沟通是管理的高境界，许多企业管理问题多是由于沟通不畅引起的。良好的沟通可以使人际关系和谐，顺利完成工作任务，达成绩效目标。沟通不良则会导致生产力、品质与服务不佳，使得成本增加。\n　(二)公司内建立良性的沟通机制\n　沟通的实现有赖与良好的机制，包括正式渠道、非正式渠道。员工不会做你期望他去做的事，只会去做奖罚去做的事和考核他去做事，因此引入沟通机制很重要。应纳入制度化、轨道化，使信息更快、更顺畅，达到高效高能的目的.\n　(三)从“头”开始抓沟通\n　企业的老总、老板是个相当重要的人物。老总必须以开放的心态来做沟通，来制定沟通机制。公司文化即老板文化，他直接决定是否能建立良性机制，构建一个开放的沟通机制。老总以身作则在公司内部构建起“开放的、分享的”企业文化。\n　(四)以良好的心态与员工沟通\n　与员工沟通必须把自己放在与员工同等的位置上，“开诚布公”、“推心置腹”、“设身处地”，否则当大家位置不同就会产生心理障碍，致使沟通不成功。沟通应抱有“五心”，即尊重的心、合作的心、服务的心、赏识的心、分享的心。只有具有这“五心”，才能使沟通效果更佳，尊重员工，学会赏识员工，与员工在工作中不断地分享知识、分享经验、分享目标、分享一切值得分享的东西。\n管理其实很简单：只要与员工保持良好的沟通，让员工参与进来，自下而上，而不是自上而下，在企业内部形成运行的机制，就可实现真正的管理。只要大家目标一致，群策群力，众志成城，企业所有的目标都会实现。那样，公司赚的钱会更多，员工也将会干得更有劲、更快乐，企业将会越做越强，越做越大，为社会创造的财富也就越多。\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E6%B2%9F%E9%80%9A/","summary":"项目沟通 通过适当和及时地生成、采集、储存、处理和发布有关项目信息，确保适当的项目干系\n项目沟通管理包括为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程。\n基本原则 准确性,完整性,及时性\n沟通在管理中的作用 　知道管理沟通的重要性后，不仅仅停止在理念层面，而应落实到执行层面，必须通过内、外部沟通机制来协助执行，以执行到位，效果更好。\n　管理沟通分外部沟通和内部沟通。\n　外部沟通一是通过公共关系手段，利用大众传媒、内部刊物等途径，与客户、政府职能部门、周边社区、金融机构等，建立良好关系，争取社会各界支持，创造好的发展氛围；二是企业导入CIS企业形象识别系统，把理念系统、行为系统、视觉系统进行有效整合，进行科学合理的传播，树立良好企业形象，提高企业的知名度、美誉度、资信度，为企业腾飞和持续发展提供好的环境。\n　内部沟通一是建立健全规范公司会议系统，使公司各种指令、计划信息能上传下达，相互协调，围绕企业各项指标的完成统筹执行。通过月会、周例会、调度会、座谈会、班前班后会等形式，快速地将信息进行有效的传递，使大家按计划有条不紊进行，步调一致，方向目标明确，提高工作效率和效能，使目标完成得到保障。二是针对公司全体员工展开“合理化建议”活动，设立合理化建议箱和[合理化建议奖。无论是技术改造、成本控制、行政管理等各领域，全面展开。从为企业发展到献计献策，树立主人翁精神，获得好的效果，从经济各个角度收获很大。三是建立公司内部刊物，每月一期，发致公司各个层面，把公司生产经营动态进行有效汇总，整合公司信息，统一全体员工思想。各车间定期办黑板报、报纸专栏，丰富职业精神生活，同时也是沟通的一种形式。五是把每周五定为公司“沟通日”。公司总经理的门是敞开着的，欢迎各级层员工进来沟通谈话。无论是意见，还是建议一并笑纳，快速做出改进，了解各级层员工的需求动态，尽可能满足他们，真正实现“以人为本”，提高员工满意度，把员工当作绩效伙伴而非“打工者”雇员，形成命运共同体，而非单纯利益共同体。六是每月集中给该月生日的员工过“生日餐会”，公司给每位生日员工发生日蛋糕、聚餐的同时，送上总经理签名的生日卡，使很多员工都很感动，感到企业大家庭的温暖，更是一心一意为公司做贡献，提升对公司的忠诚度和凝聚力。还有定期举办的联欢会、运动会、表彰会、优秀员工干部旅游活动等，使大家干得起劲、玩得开心，觉得自己与公司已密不可分，人企合一，共同成长，把公司当成自己创业、施展才能的大舞台，产生良好的效果。\n如何沟通 　(一)首先让管理者意识到沟通的重要性。\n　沟通是管理的高境界，许多企业管理问题多是由于沟通不畅引起的。良好的沟通可以使人际关系和谐，顺利完成工作任务，达成绩效目标。沟通不良则会导致生产力、品质与服务不佳，使得成本增加。\n　(二)公司内建立良性的沟通机制\n　沟通的实现有赖与良好的机制，包括正式渠道、非正式渠道。员工不会做你期望他去做的事，只会去做奖罚去做的事和考核他去做事，因此引入沟通机制很重要。应纳入制度化、轨道化，使信息更快、更顺畅，达到高效高能的目的.\n　(三)从“头”开始抓沟通\n　企业的老总、老板是个相当重要的人物。老总必须以开放的心态来做沟通，来制定沟通机制。公司文化即老板文化，他直接决定是否能建立良性机制，构建一个开放的沟通机制。老总以身作则在公司内部构建起“开放的、分享的”企业文化。\n　(四)以良好的心态与员工沟通\n　与员工沟通必须把自己放在与员工同等的位置上，“开诚布公”、“推心置腹”、“设身处地”，否则当大家位置不同就会产生心理障碍，致使沟通不成功。沟通应抱有“五心”，即尊重的心、合作的心、服务的心、赏识的心、分享的心。只有具有这“五心”，才能使沟通效果更佳，尊重员工，学会赏识员工，与员工在工作中不断地分享知识、分享经验、分享目标、分享一切值得分享的东西。\n管理其实很简单：只要与员工保持良好的沟通，让员工参与进来，自下而上，而不是自上而下，在企业内部形成运行的机制，就可实现真正的管理。只要大家目标一致，群策群力，众志成城，企业所有的目标都会实现。那样，公司赚的钱会更多，员工也将会干得更有劲、更快乐，企业将会越做越强，越做越大，为社会创造的财富也就越多。","title":""},{"content":"在sklearn中包含四种评价尺度，分别为mean_squared_error、mean_absolute_error、explained_variance_score 和 r2_score。\n1、均方差（mean-squared-error）\n2、平均绝对值误差（mean_absolute_error）\n3、可释方差得分（explained_variance_score） explained variation measures the proportion to which a mathematical model accounts for the variation (dispersion) of a given data set\n4、中值绝对误差（Median absolute error）\n此种方法非常适应含有离群点的数据集\n5、R2 决定系数（拟合优度） 它是表征回归方程在多大程度上解释了因变量的变化，或者说方程对观测值的拟合程度如何。 因为如果单纯用残差平方和会受到你因变量和自变量绝对值大小的影响，不利于在不同模型之间进行相对比较.而用拟合优度就可以解决这个问题。例如一个模型中的因变量:10000、20000…..，而另一个模型中因变量为1、2……，这两个模型中第一个模型的残差平方和可能会很大,而另一个会很小，但是这不能说明第一个模型就别第二个模型差。\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E6%B5%8B%E5%BA%A6/","summary":"在sklearn中包含四种评价尺度，分别为mean_squared_error、mean_absolute_error、explained_variance_score 和 r2_score。\n1、均方差（mean-squared-error）\n2、平均绝对值误差（mean_absolute_error）\n3、可释方差得分（explained_variance_score） explained variation measures the proportion to which a mathematical model accounts for the variation (dispersion) of a given data set\n4、中值绝对误差（Median absolute error）\n此种方法非常适应含有离群点的数据集\n5、R2 决定系数（拟合优度） 它是表征回归方程在多大程度上解释了因变量的变化，或者说方程对观测值的拟合程度如何。 因为如果单纯用残差平方和会受到你因变量和自变量绝对值大小的影响，不利于在不同模型之间进行相对比较.而用拟合优度就可以解决这个问题。例如一个模型中的因变量:10000、20000…..，而另一个模型中因变量为1、2……，这两个模型中第一个模型的残差平方和可能会很大,而另一个会很小，但是这不能说明第一个模型就别第二个模型差。","title":""},{"content":"点菜测试 | 花30秒看你是个怎样的人？ 作者：佚名|文章出处：性格心理测试|更新时间：2016-05-10\n　如果你和朋友一起吃饭。点菜的时候你会怎么做？\n　A：只点自己喜欢的，不管别人是否喜欢\n　B：先把自己的意见提出来\n　C：跟着别人，别人想吃什么就是什么\n　D：主动点菜，再询问别人的意见，再做更改\n　E：点菜时候犹豫不决，慢吞吞的\n　F：先让店员介绍菜式再点菜\n　答案分析\n　选A的你\n　你是个乐观派，生活中完全不拘小节。\n　你做事果断，但不计后果。\n　但A答案再细分为三种类型：\n　只要价钱合适迅速做出决定是合理型；\n　根据饮食喜好直接选择的人是享受型；\n　在价格，内容上不断比较才决定的人是吝啬型。\n　选B的你\n　你多是从众型的。做事小心翼翼，缺乏自己的想法。\n　你往往忽视了自我的存在，对自己没有信心。\n　要注意这一点哦。\n　选C的你\n　你性格直爽，胸襟开阔。\n　就算难以启齿的事也可以若无其事的表达出来。\n　你为人光明磊落。\n　虽然有时候说话刻薄了点，但大家其实还蛮喜欢你爽朗的一面。\n　选D的你\n　你小心谨慎，在工作和人际交往上经常犹豫。\n　你给人最直接的印象是软弱的，不堪一击的。\n　过分讲究细节上，缺乏掌握全局的意识。\n　选E的你\n　你做事一板一眼，安全第一。\n　但有时候过分谨慎，过多考虑对方立场。\n　在听取别人观点的同时，别忘了自己最真实的想法哦。\n　选F的你\n　你自尊心强，最不能接受别人的指挥。\n　做任何事都坚持自己的主张。\n　你做事积极，在待人方面，懂得维护双方的面子。\n　很好奇，选哪个答案的人最多？\n​ **学习资讯：**如何洞悉性格的秘密？\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E7%82%B9%E8%8F%9C%E6%B5%8B%E8%AF%95-%E8%8A%B130%E7%A7%92%E7%9C%8B%E4%BD%A0%E6%98%AF%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BA%BA/","summary":"点菜测试 | 花30秒看你是个怎样的人？ 作者：佚名|文章出处：性格心理测试|更新时间：2016-05-10\n　如果你和朋友一起吃饭。点菜的时候你会怎么做？\n　A：只点自己喜欢的，不管别人是否喜欢\n　B：先把自己的意见提出来\n　C：跟着别人，别人想吃什么就是什么\n　D：主动点菜，再询问别人的意见，再做更改\n　E：点菜时候犹豫不决，慢吞吞的\n　F：先让店员介绍菜式再点菜\n　答案分析\n　选A的你\n　你是个乐观派，生活中完全不拘小节。\n　你做事果断，但不计后果。\n　但A答案再细分为三种类型：\n　只要价钱合适迅速做出决定是合理型；\n　根据饮食喜好直接选择的人是享受型；\n　在价格，内容上不断比较才决定的人是吝啬型。\n　选B的你\n　你多是从众型的。做事小心翼翼，缺乏自己的想法。\n　你往往忽视了自我的存在，对自己没有信心。\n　要注意这一点哦。\n　选C的你\n　你性格直爽，胸襟开阔。\n　就算难以启齿的事也可以若无其事的表达出来。\n　你为人光明磊落。\n　虽然有时候说话刻薄了点，但大家其实还蛮喜欢你爽朗的一面。\n　选D的你\n　你小心谨慎，在工作和人际交往上经常犹豫。\n　你给人最直接的印象是软弱的，不堪一击的。\n　过分讲究细节上，缺乏掌握全局的意识。\n　选E的你\n　你做事一板一眼，安全第一。\n　但有时候过分谨慎，过多考虑对方立场。\n　在听取别人观点的同时，别忘了自己最真实的想法哦。\n　选F的你","title":""},{"content":"移动开发：实用的移动开发工具（一） 切图 2017-08-21 08:41:13\n此文为大家推荐几款实用的移动开发工具，希望对大家有所帮助！\n1、Pusher（推杆的移动推送通知API。它让你可以构建跨平台的应用程序，发送程序的推送通知到iOS和Android设备。）\n2、Weex（是一个跨平台的移动用户界面框架。它是重量轻，高性能；可扩展。）\n3、CloudRail（是Android和iOS的API库，java，让你多服务只是一个API整合。这是完全免费的个人和商业项目。）\n4、Rikulo（是一个用于创建与 HTML5的跨平台Web和本地移动应用飞镖框架。）\n5、Truck（一个开源的移动应用程序框架。它提供了布局，部件，触摸手势，数据过滤，数据绑定，等等，都有干净的代码。）\n6、Tabris.js（一个移动的框架，它使简单的创建在JavaScript原生iOS和Android应用程序。）\n切图 qietu(.com)\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%80/","summary":"移动开发：实用的移动开发工具（一） 切图 2017-08-21 08:41:13\n此文为大家推荐几款实用的移动开发工具，希望对大家有所帮助！\n1、Pusher（推杆的移动推送通知API。它让你可以构建跨平台的应用程序，发送程序的推送通知到iOS和Android设备。）\n2、Weex（是一个跨平台的移动用户界面框架。它是重量轻，高性能；可扩展。）\n3、CloudRail（是Android和iOS的API库，java，让你多服务只是一个API整合。这是完全免费的个人和商业项目。）\n4、Rikulo（是一个用于创建与 HTML5的跨平台Web和本地移动应用飞镖框架。）\n5、Truck（一个开源的移动应用程序框架。它提供了布局，部件，触摸手势，数据过滤，数据绑定，等等，都有干净的代码。）\n6、Tabris.js（一个移动的框架，它使简单的创建在JavaScript原生iOS和Android应用程序。）\n切图 qietu(.com)","title":""},{"content":"列表到详情接口 列表 https://unidemo.dcloud.net.cn/api/news\n 返回数据格式 post_id 新闻id 如 ： 72980 title 标题 created_at 创建时间 author_avatar 图标  详情 地址：https://unidemo.dcloud.net.cn/api/news/36kr/ + id（id为新闻id，上个页面传过来的）\n使用 rich-text 【富文本组件】来展示新闻内容 \n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E7%AC%AC3%E8%AE%B2api%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E20181025/","summary":"列表到详情接口 列表 https://unidemo.dcloud.net.cn/api/news\n 返回数据格式 post_id 新闻id 如 ： 72980 title 标题 created_at 创建时间 author_avatar 图标  详情 地址：https://unidemo.dcloud.net.cn/api/news/36kr/ + id（id为新闻id，上个页面传过来的）\n使用 rich-text 【富文本组件】来展示新闻内容","title":""},{"content":"1.河内之塔.. 2.Algorithm Gossip: 费式数列. 3. 巴斯卡三角形 4.Algorithm Gossip: 三色棋 5.Algorithm Gossip: 老鼠走迷官（一） 6.Algorithm Gossip: 老鼠走迷官（二） 7.Algorithm Gossip: 骑士走棋盘 8.Algorithm Gossip: 八皇后 9.Algorithm Gossip: 八枚银币. 10.Algorithm Gossip: 生命游戏. 11.Algorithm Gossip: 字串核对 12.Algorithm Gossip: 双色、三色河内塔 13.Algorithm Gossip: 背包问题（Knapsack Problem 14.Algorithm Gossip: 蒙地卡罗法求 PI 15.Algorithm Gossip: Eratosthenes 筛选求质数 16.Algorithm Gossip: 超长整数运算（大数运算）. 17.Algorithm Gossip: 长 PI. 18.Algorithm Gossip: 最大公因数、最小公倍数、因式分解 19.Algorithm Gossip: 完美数\u0026hellip; 20.Algorithm Gossip: 阿姆斯壮数. 21.Algorithm Gossip: 最大访客数\u0026hellip;. 22.Algorithm Gossip: 中序式转后序式（前序式）\u0026hellip; 23.Algorithm Gossip: 后序式的运算. 24.Algorithm Gossip: 洗扑克牌（乱数排列） 25.Algorithm Gossip: Craps 赌博游戏. 26.Algorithm Gossip: 约瑟夫问题（Josephus Problem） 27.Algorithm Gossip: 排列组合. 28.Algorithm Gossip: 格雷码（Gray Code 29.Algorithm Gossip: 产生可能的集合 30.Algorithm Gossip: m 元素集合的 n 个元素子集 31.Algorithm Gossip: 数字拆解 32.Algorithm Gossip: 得分排行 33.Algorithm Gossip: 选择、插入、气泡排序 34.Algorithm Gossip: Shell 排序法 - 改良的插入排序 35.Algorithm Gossip: Shaker 排序法 - 改良的气泡排序 36.排序法 - 改良的选择 37.Algorithm Gossip:速排序法（一） 38.Algorithm Gossip: 快速排序法（二） 39.Algorithm Gossip: 快速排序法（三） 40.Algorithm Gossip: 合并排序法 41.Algorithm Gossip: 基数排序法. 42.Algorithm Gossip: 循序搜寻法（使用卫兵） 43.Algorithm Gossip: 二分搜寻法（搜寻原则的代表） 44.Algorithm Gossip: 插补搜寻法. 45.Algorithm Gossip: 费氏搜寻法. 46.Algorithm Gossip: 稀疏矩阵 47.Algorithm Gossip: 多维矩阵转一维矩阵 48.Algorithm Gossip: 上三角、下三角、对称矩阵 49.Algorithm Gossip: 奇数魔方阵 50.Algorithm Gossip: 4N 魔方阵. 51.Algorithm Gossip: 2(2N+1) 1.河内之塔 说明 河内之塔(Towers of Hanoi)是法国人M.Claus(Lucas)于1883年从泰国带至法国的，河内为越战时 北越的首都，即现在的胡志明市；1883年法国数学家 Edouard Lucas曾提及这个故事，据说创世 纪时Benares有一座波罗教塔，是由三支钻石棒（Pag）所支撑，开始时神在第一根棒上放置64 个由上至下依由小至大排列的金盘（Disc），并命令僧侣将所有的金盘从第一根石棒移至第三根 石棒，且搬运过程中遵守大盘子在小盘子之下的原则，若每日仅搬一个盘子，则当盘子全数搬 运完毕之时，此塔将毁损，而也就是世界末日来临之时。 解法如果柱子标为ABC，要由A搬至C，在只有一个盘子时，就将它直接搬至C，当有两个盘 子，就将B当作辅助柱。如果盘数超过2个，将第三个以下的盘子遮起来，就很简单了，每次处 理两个盘子，也就是：A-\u0026gt;B、A -\u0026gt;C、B-\u0026gt;C这三个步骤，而被遮住的部份，其实就是进入程式 的递回处理。事实上，若有n个盘子，则移动完毕所需之次数为2^n - 1，所以当盘数为64时，则 64 如果对这数字没什幺概念，就假设每秒钟搬一个盘子好了，也要约5850亿年左右。\n#include \u0026lt;stdio.h\u0026gt;void hanoi(int n, char A, char B, char C) { if(n == 1) { printf(\u0026#34;Move sheet %d from %c to %c\\n\u0026#34;, n, A, C); } else { hanoi(n-1, A, C, B); printf(\u0026#34;Move sheet %d from %c to %c\\n\u0026#34;, n, A, C); hanoi(n-1, B, A, C); } } int main() int n; printf(\u0026#34;请输入盘数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); hanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;); return 0; } 所需次数为： 2-1=18446744073709551615为5.05390248594782e+16年，也就是约5000世纪 2.Algorithm Gossip: 费式数列 说明 Fibonacci为1200年代的欧洲数学家，在他的着作中曾经提到：「若有一只免子每个月生一只小免 子，一个月后小免子也开始生产。起初只有一只免子，一个月后就有两只免子，二个月后有三 只免子，三个月后有五只免子（小免子投入生产）\u0026hellip;\u0026hellip;。 如果不太理解这个例子的话，举个图就知道了，注意新生的小免子需一个月成长期才会投入生 产，类似的道理也可以用于植物的生长，这就是Fibonacci数列，一般习惯称之为费氏数列，例 如以下： 1、1 、2、3、5、8、13、21、34、55、89\u0026hellip;\u0026hellip; 解法 依说明，我们可以将费氏数列定义为以下： fn = fn-1 + fn-2 fn = n if n \u0026gt; 1 if n = 0, 1\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#define N 20 int main(void) { int Fib[N] = {0}; int i; Fib[0] = 0; Fib[1] = 1; for(i = 2; i \u0026lt; N; i++) Fib[i] = Fib[i-1] + Fib[i-2]; for(i = 0; i \u0026lt; N; i++) printf(\u0026#34;%d \u0026#34;, Fib[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } 巴斯卡三角形  #include \u0026lt;stdio.h\u0026gt;#define N 12 long combi(int n, int r){ int i; long p = 1; for(i = 1; i \u0026lt;= r; i++) p = p * (n-i+1) / i; return p; } void paint() { int n, r, t; for(n = 0; n \u0026lt;= N; n++) { for(r = 0; r \u0026lt;= n; r++) { int i;/* 排版设定开始 */ if(r == 0) { for(i = 0; i \u0026lt;= (N-n); i++)  }else {  printf(\u0026#34;  \u0026#34;);  printf(\u0026#34;  \u0026#34;);  } /* 排版设定结束 */ printf(\u0026#34;%3d\u0026#34;, combi(n, r));   } printf(\u0026#34;\\n\u0026#34;); } } 4.Algorithm Gossip: 三色棋 说明 三色旗的问题最早由E.W.Dijkstra所提出，他所使用的用语为Dutch Nation Flag(Dijkstra为荷兰 人)，而多数的作者则使用Three-Color Flag来称之。 假设有一条绳子，上面有红、白、蓝三种颜色的旗子，起初绳子上的旗子颜色并没有顺序，您 希望将之分类，并排列为蓝、白、红的顺序，要如何移动次数才会最少，注意您只能在绳子上 进行这个动作，而且一次只能调换两个旗子。 解法 在一条绳子上移动，在程式中也就意味只能使用一个阵列，而不使用其它的阵列来作辅助，问 题的解法很简单，您可以自己想像一下在移动旗子，从绳子开头进行，遇到蓝色往前移，遇到 白色留在中间，遇到红色往后移，如下所示： 只是要让移动次数最少的话，就要有些技巧： 如果图中W所在的位置为白色，则W+1，表示未处理的部份移至至白色群组。 如果W部份为蓝色，则B与W的元素对调，而B与W必须各+1，表示两个群组都多了一个元素。 如果W所在的位置是红色，则将W与R交换，但R要减1，表示未处理的部份减1。 注意B、W、R并不是三色旗的个数，它们只是一个移动的指标；什幺时候移动结束呢？一开始 时未处理的R指标会是等于旗子的总数，当R的索引数减至少于W的索引数时，表示接下来的旗 子就都是红色了，此时就可以结束移动，如下所示： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define BLUE \u0026lsquo;b\u0026rsquo; #define WHITE \u0026lsquo;w\u0026rsquo; #define RED \u0026lsquo;r\u0026rsquo; #define SWAP(x, y) { char temp; \\ temp = color[x]; color[x] = color[y]; color[y] = temp; } int main() { char color[] = {\u0026lsquo;r\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;r\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026lsquo;r\u0026rsquo;, \u0026lsquo;\\0\u0026rsquo;}; int wFlag = 0; int bFlag = 0; int rFlag = strlen(color) - 1; int i; for(i = 0; i \u0026lt; strlen(color); i++) printf(\u0026quot;%c \u0026ldquo;, color[i]); printf(\u0026quot;\\n\u0026rdquo;); while(wFlag \u0026lt;= rFlag) { if(color[wFlag] == WHITE) wFlag++; else if(color[wFlag] == BLUE) { SWAP(bFlag, wFlag); bFlag++; wFlag++; } else { while(wFlag \u0026lt; rFlag \u0026amp;\u0026amp; color[rFlag] == RED) rFlag\u0026ndash;; SWAP(rFlag, wFlag); rFlag\u0026ndash;; } } for(i = 0; i \u0026lt; strlen(color); i++) printf(\u0026quot;%c \u0026ldquo;, color[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } 5.Algorithm Gossip: 老鼠走迷官（一） 说明老鼠走迷宫是递回求解的基本题型，我们在二维阵列中使用2表示迷宫墙壁，使用1来表 示老鼠的行走路径，试以程式求出由入口至出口的路径。 解法老鼠的走法有上、左、下、右四个方向，在每前进一格之后就选一个方向前进，无法前 进时退回选择下一个可前进方向，如此在阵列中依序测试四个方向，直到走到出口为止，这是 递回的基本题，请直接看程式应就可以理解。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int visit(int, int); int maze[7][7] = {{2, 2, 2, 2, 2, 2, 2}, {2, 0, 0, 0, 0, 0, 2}, {2, 0, 2, 0, 2, 0, 2}, {2, 0, 0, 2, 0, 2, 2}, {2, 2, 0, 2, 0, 2, 2}, {2, 0, 0, 0, 0, 0, 2}, {2, 2, 2, 2, 2, 2, 2}}; int startI = 1, startJ = 1; // 入口 int endI = 5, endJ = 5; // 出口 int success = 0; int main(void) { int i, j; printf(\u0026ldquo;显示迷宫：\\n\u0026rdquo;); for(i = 0; i \u0026lt; 7; i++) { for(j = 0; j \u0026lt; 7; j++) if(maze[i][j] == 2) printf(\u0026ldquo;█\u0026rdquo;); else\nprintf(\u0026quot;\n\u0026ldquo;);\nprintf(\u0026quot;\\n\u0026rdquo;); } if(visit(startI, startJ) == 0) printf(\u0026quot;\\n没有找到出口！\\n\u0026quot;); else { printf(\u0026quot;\\n显示路径：\\n\u0026quot;); for(i = 0; i \u0026lt; 7; i++) { for(j = 0; j \u0026lt; 7; j++) { if(maze[i][j] == 2) printf(\u0026ldquo;█\u0026rdquo;); else if(maze[i][j] == 1) printf(\u0026ldquo;◇\u0026rdquo;); else\nprintf(\u0026quot;\n\u0026ldquo;);\n} printf(\u0026quot;\\n\u0026rdquo;); } } return 0; } int visit(int i, int j) { maze[i][j] = 1; if(i == endI \u0026amp;\u0026amp; j == endJ) success = 1; if(success != 1 \u0026amp;\u0026amp; maze[i][j+1] == 0) visit(i, j+1); if(success != 1 \u0026amp;\u0026amp; maze[i+1][j] == 0) visit(i+1, j); if(success != 1 \u0026amp;\u0026amp; maze[i][j-1] == 0) visit(i, j-1); if(success != 1 \u0026amp;\u0026amp; maze[i-1][j] == 0) visit(i-1, j); if(success != 1) maze[i][j] = 0; return success; } 6.Algorithm Gossip: 老鼠走迷官（二） 说明由于迷宫的设计，老鼠走迷宫的入口至出口路径可能不只一条，如何求出所有的路径呢？ 解法求所有路径看起来复杂但其实更简单，只要在老鼠走至出口时显示经过的路径，然后退 回上一格重新选择下一个位置继续递回就可以了，比求出单一路径还简单，我们的程式只要作 一点修改就可以了。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void visit(int, int); int maze[9][9] = {{2, 2, 2, 2, 2, 2, 2, 2, 2}, {2, 0, 0, 0, 0, 0, 0, 0, 2}, {2, 0, 2, 2, 0, 2, 2, 0, 2}, {2, 0, 2, 0, 0, 2, 0, 0, 2}, {2, 0, 2, 0, 2, 0, 2, 0, 2}, {2, 0, 0, 0, 0, 0, 2, 0, 2}, {2, 2, 0, 2, 2, 0, 2, 2, 2}, {2, 0, 0, 0, 0, 0, 0, 0, 2}, {2, 2, 2, 2, 2, 2, 2, 2, 2}}; int startI = 1, startJ = 1; // 入口 int endI = 7, endJ = 7; // 出口 int main(void) { int i, j; printf(\u0026ldquo;显示迷宫：\\n\u0026rdquo;); for(i = 0; i \u0026lt; 7; i++) { for(j = 0; j \u0026lt; 7; j++) if(maze[i][j] == 2) printf(\u0026ldquo;█\u0026rdquo;); else\nprintf(\u0026quot;\n\u0026ldquo;);\nprintf(\u0026quot;\\n\u0026rdquo;); } visit(startI, startJ); return 0; } void visit(int i, int j) { int m, n; maze[i][j] = 1; if(i == endI \u0026amp;\u0026amp; j == endJ) { printf(\u0026quot;\\n显示路径：\\n\u0026quot;); for(m = 0; m \u0026lt; 9; m++) { for(n = 0; n \u0026lt; 9; n++) if(maze[m][n] == 2) printf(\u0026ldquo;█\u0026rdquo;); else if(maze[m][n] == 1) printf(\u0026ldquo;◇\u0026rdquo;); else\nprintf(\u0026quot;\n\u0026ldquo;);\nprintf(\u0026quot;\\n\u0026rdquo;); } } if(maze[i][j+1] == 0) visit(i, j+1); if(maze[i+1][j] == 0) visit(i+1, j); if(maze[i][j-1] == 0) visit(i, j-1); if(maze[i-1][j] == 0) visit(i-1, j); maze[i][j] = 0; } 7.Algorithm Gossip: 骑士走棋盘 说明骑士旅游（Knight tour）在十八世纪初倍受数学家与拼图迷的注意，它什么时候被提出 已不可考，骑士的走法为西洋棋的走法，骑士可以由任一个位置出发，它要如何走完[所有的位 置？ 解法骑士的走法，基本上可以使用递回来解决，但是纯綷的递回在维度大时相当没有效率， 一个聪明的解法由J.C. Warnsdorff在1823年提出，简单的说，先将最难的位置走完，接下来的路 就宽广了，骑士所要走的下一步，「为下一步再选择时，所能走的步数最少的一步。」，使用这个 方法，在不使用递回的情况下，可以有较高的机率找出走法（找不到走法的机会也是有的）。 #include \u0026lt;stdio.h\u0026gt; int board[8][8] = {0}; int main(void) { int startx, starty; int i, j; printf(\u0026ldquo;输入起始点：\u0026rdquo;); scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;startx, \u0026amp;starty); if(travel(startx, starty)) { printf(\u0026ldquo;游历完成！\\n\u0026rdquo;); } else { printf(\u0026ldquo;游历失败！\\n\u0026rdquo;); } for(i = 0; i \u0026lt; 8; i++) { for(j = 0; j \u0026lt; 8; j++) { printf(\u0026quot;%2d \u0026ldquo;, board[i][j]); } putchar(\u0026rsquo;\\n\u0026rsquo;); } return 0; } int travel(int x, int y) { // 对应骑士可走的八个方向 int ktmove1[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; int ktmove2[8] = {1, 2, 2, 1, -1, -2, -2, -1}; // 测试下一步的出路 int nexti[8] = {0}; int nextj[8] = {0}; // 记录出路的个数 int exists[8] = {0}; int i, j, k, m, l; int tmpi, tmpj; int count, min, tmp; i = x; j = y; board[i][j] = 1; for(m = 2; m \u0026lt;= 64; m++) { for(l = 0; l \u0026lt; 8; l++) exists[l] = 0; l = 0; // 试探八个方向 for(k = 0; k \u0026lt; 8; k++) { tmpi = i + ktmove1[k]; tmpj = j + ktmove2[k]; // 如果是边界了，不可走 if(tmpi \u0026lt; 0 || tmpj \u0026lt; 0 || tmpi \u0026gt; 7 || tmpj \u0026gt; 7) continue; // 如果这个方向可走，记录下来 if(board[tmpi][tmpj] == 0) { nexti[l] = tmpi; nextj[l] = tmpj; // 可走的方向加一个 l++; } } count = l; // 如果可走的方向为0个，返回 if(count == 0) { return 0; } else if(count == 1) { // 只有一个可走的方向 // 所以直接是最少出路的方向 min = 0; } else { // 找出下一个位置的出路数 for(l = 0; l \u0026lt; count; l++) { for(k = 0; k \u0026lt; 8; k++) { tmpi = nexti[l] + ktmove1[k]; tmpj = nextj[l] + ktmove2[k]; if(tmpi \u0026lt; 0 || tmpj \u0026lt; 0 || tmpi \u0026gt; 7 || tmpj \u0026gt; 7) { continue; } if(board[tmpi][tmpj] == 0) exists[l]++; } } tmp = exists[0]; min = 0; // 从可走的方向中寻找最少出路的方向 for(l = 1; l \u0026lt; count; l++) { if(exists[l] \u0026lt; tmp) { tmp = exists[l]; min = l; } } } // 走最少出路的方向 i = nexti[min]; j = nextj[min]; board[i][j] = m; } return 1; } 8.Algorithm Gossip: 八皇后 说明西洋棋中的皇后可以直线前进，吃掉遇到的所有棋子，如果棋盘上有八个皇后，则这八 个皇后如何相安无事的放置在棋盘上，1970年与1971年， E.W.Dijkstra与N.Wirth曾经用这个问 题来讲解程式设计之技巧。 解法关于棋盘的问题，都可以用递回求解，然而如何减少递回的次数？在八个皇后的问题中， 不必要所有的格子都检查过，例如若某列检查过，该该列的其它格子就不用再检查了，这个方 法称为分支修剪。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 8 int column[N+1]; // 同栏是否有皇后，1表示有 int rup[2N+1]; // 右上至左下是否有皇后 int lup[2N+1]; // 左上至右下是否有皇后 int queen[N+1] = {0}; int num; // 解答编号 void backtrack(int); // 递回求解 int main(void) { int i; num = 0; for(i = 1; i \u0026lt;= N; i++) column[i] = 1; for(i = 1; i \u0026lt;= 2*N; i++) rup[i] = lup[i] = 1; backtrack(1); return 0; } void showAnswer() { int x, y; printf(\u0026quot;\\n解答 %d\\n\u0026rdquo;, ++num); for(y = 1; y \u0026lt;= N; y++) { for(x = 1; x \u0026lt;= N; x++) { if(queen[y] == x) { printf(\u0026quot; Q\u0026quot;); } else { printf(\u0026quot; .\u0026quot;); } } printf(\u0026quot;\\n\u0026quot;); } } void backtrack(int i) { int j; if(i \u0026gt; N) { showAnswer(); } else { for(j = 1; j \u0026lt;= N; j++) { if(column[j] == 1 \u0026amp;\u0026amp; rup[i+j] == 1 \u0026amp;\u0026amp; lup[i-j+N] == 1) { queen[i] = j; // 设定为占用 column[j] = rup[i+j] = lup[i-j+N] = 0; backtrack(i+1); column[j] = rup[i+j] = lup[i-j+N] = 1; } } } } 9.Algorithm Gossip: 八枚银币 说明现有八枚银币a b c d e f g h，已知其中一枚是假币，其重量不同于真币，但不知是较轻或 较重，如何使用天平以最少的比较次数，决定出哪枚是假币，并得知假币比真币较轻或较重。 解法单就求假币的问题是不难，但问题限制使用最少的比较次数，所以我们不能以单纯的回 圈比较来求解，我们可以使用决策树（decision tree），使用分析与树状图来协助求解。一个简单 的状况是这样的，我们比较a+b+c与d+e+f ，如果相等，则假币必是g或h，我们先比较g或h哪个 较重，如果g较重，再与a比较（a是真币），如果g等于a，则g为真币，则h为假币，由于h比g轻 而 g是真币，则h假币的重量比真币轻。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; void compare(int[], int, int, int); void eightcoins(int[]); int main(void) { int coins[8] = {0}; int i; srand(time(NULL)); for(i = 0; i \u0026lt; 8; i++) coins[i] = 10; printf(\u0026quot;\\n输入假币重量(比10大或小)：\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); coins[rand() % 8] = i; eightcoins(coins); printf(\u0026quot;\\n\\n列出所有钱币重量：\u0026quot;); for(i = 0; i \u0026lt; 8; i++) printf(\u0026quot;%d \u0026ldquo;, coins[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } void compare(int coins[], int i, int j, int k) { if(coins[i] \u0026gt; coins[k]) printf(\u0026quot;\\n假币 %d 较重\u0026quot;, i+1); else printf(\u0026quot;\\n假币 %d 较轻\u0026quot;, j+1); } void eightcoins(int coins[]) { if(coins[0]+coins[1]+coins[2] == coins[3]+coins[4]+coins[5]) { if(coins[6] \u0026gt; coins[7]) compare(coins, 6, 7, 0); else compare(coins, 7, 6, 0); } else if(coins[0]+coins[1]+coins[2] \u0026gt; coins[3]+coins[4]+coins[5]) { if(coins[0]+coins[3] == coins[1]+coins[4]) compare(coins, 2, 5, 0); else if(coins[0]+coins[3] \u0026gt; coins[1]+coins[4]) compare(coins, 0, 4, 1); if(coins[0]+coins[3] \u0026lt; coins[1]+coins[4]) compare(coins, 1, 3, 0); } else if(coins[0]+coins[1]+coins[2] \u0026lt; coins[3]+coins[4]+coins[5]) { if(coins[0]+coins[3] == coins[1]+coins[4]) compare(coins, 5, 2, 0); else if(coins[0]+coins[3] \u0026gt; coins[1]+coins[4]) compare(coins, 3, 1, 0); if(coins[0]+coins[3] \u0026lt; coins[1]+coins[4]) compare(coins, 4, 0, 1); } } 10.Algorithm Gossip: 生命游戏 说明生命游戏（game of life）为1970年由英国数学家J. H. Conway所提出，某一细胞的邻居包 括上、下、左、右、左上、左下、右上与右下相邻之细胞，游戏规则如下： 孤单死亡：如果细胞的邻居小于一个，则该细胞在下一次状态将死亡。 拥挤死亡：如果细胞的邻居在四个以上，则该细胞在下一次状态将死亡。 稳定：如果细胞的邻居为二个或三个，则下一次状态为稳定存活。 复活：如果某位置原无细胞存活，而该位置的邻居为三个，则该位置将复活一细胞。 解法生命游戏的规则可简化为以下，并使用CASE比对即可使用程式实作： 邻居个数为0、1、4、5、6、7、8时，则该细胞下次状态为死亡。 邻居个数为2时，则该细胞下次状态为复活。 邻居个数为3时，则该细胞下次状态为稳定。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAXROW 10 #define MAXCOL 25 #define DEAD 0 #define ALIVE 1 int map[MAXROW][MAXCOL], newmap[MAXROW][MAXCOL]; void init(); int neighbors(int, int); void outputMap(); void copyMap(); int main() { int row, col; char ans; init(); while(1) { outputMap(); for(row = 0; row \u0026lt; MAXROW; row++) { for(col = 0; col \u0026lt; MAXCOL; col++) { switch (neighbors(row, col)) { case 0: case 1: case 4: case 5: case 6: case 7: case 8: newmap[row][col] = DEAD; break; case 2: newmap[row][col] = map[row][col]; break; case 3: newmap[row][col] = ALIVE; break; } } } copyMap(); printf(\u0026quot;\\nContinue next Generation ? \u0026ldquo;); getchar(); ans = toupper(getchar());\n}\nif(ans != \u0026lsquo;Y\u0026rsquo;)\nbreak; return 0; } void init() { int row, col; for(row = 0; row \u0026lt; MAXROW; row++) for(col = 0; col \u0026lt; MAXCOL; col++) map[row][col] = DEAD; puts(\u0026ldquo;Game of life Program\u0026rdquo;); puts(\u0026ldquo;Enter x, y where x, y is living cell\u0026rdquo;); printf(\u0026ldquo;0 \u0026lt;= x \u0026lt;= %d, 0 \u0026lt;= y \u0026lt;= %d\\n\u0026rdquo;, MAXROW-1, MAXCOL-1); puts(\u0026ldquo;Terminate with x, y = -1, -1\u0026rdquo;); while(1) { scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;row, \u0026amp;col); if(0 \u0026lt;= row \u0026amp;\u0026amp; row \u0026lt; MAXROW \u0026amp;\u0026amp; 0 \u0026lt;= col \u0026amp;\u0026amp; col \u0026lt; MAXCOL) map[row][col] = ALIVE; else if(row == -1 || col == -1) break; else printf(\u0026quot;(x, y) exceeds map ranage!\u0026quot;); } } int neighbors(int row, int col) { int count = 0, c, r; for(r = row-1; r \u0026lt;= row+1; r++) for(c = col-1; c \u0026lt;= col+1; c++) { if(r \u0026lt; 0 || r \u0026gt;= MAXROW || c \u0026lt; 0 || c \u0026gt;= MAXCOL) continue; if(map[r][c] == ALIVE) count++; } if(map[row][col] == ALIVE) count\u0026ndash;; return count; } void outputMap() { int row, col; printf(\u0026quot;\\n\\n%20cGame of life cell status\\n\u0026quot;); for(row = 0; row \u0026lt; MAXROW; row++) { printf(\u0026quot;\\n%20c\u0026quot;, \u0026rsquo; \u0026lsquo;); for(col = 0; col \u0026lt; MAXCOL; col++)\nif(map[row][col] == ALIVE)\nputchar(\u0026rsquo;#\u0026rsquo;);\nelse\nputchar(\u0026rsquo;-\u0026rsquo;);\n} } void copyMap() { int row, col; for(row = 0; row \u0026lt; MAXROW; row++) for(col = 0; col \u0026lt; MAXCOL; col++) map[row][col] = newmap[row][col]; } 11.Algorithm Gossip: 字串核对 说明今日的一些高阶程式语言对于字串的处理支援越来越强大（例如Java、Perl等），不过字 串搜寻本身仍是个值得探讨的课题，在这边以 Boyer- Moore法来说明如何进行字串说明，这个 方法快且原理简洁易懂。 解法字串搜寻本身不难，使用暴力法也可以求解，但如何快速搜寻字串就不简单了，传统的 字串搜寻是从关键字与字串的开头开始比对，例如 Knuth-Morris-Pratt 演算法 字串搜寻，这个 方法也不错，不过要花时间在公式计算上；Boyer-Moore字串核对改由关键字的后面开始核对字 串，并制作前进表，如果比对不符合则依前进表中的值前进至下一个核对处，假设是p好了，然 后比对字串中p-n+1至p的值是否与关键字相同。 如果关键字中有重复出现的字元，则前进值就会有两个以上的值，此时则取前进值较小的值， 如此就不会跳过可能的位置，例如texture这个关键字，t的前进值应该取后面的3而不是取前面的 7。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void table(char*); // 建立前进表 int search(int, char*, char*); // 搜寻关键字 void substring(char*, char*, int, int); // 取出子字串 int skip[256]; int main(void) { char str_input[80]; char str_key[80]; char tmp[80] = {\u0026rsquo;\\0\u0026rsquo;}; int m, n, p; printf(\u0026ldquo;请输入字串：\u0026rdquo;); gets(str_input); printf(\u0026ldquo;请输入搜寻关键字：\u0026rdquo;); gets(str_key); m = strlen(str_input); // 计算字串长度 n = strlen(str_key); table(str_key); p = search(n-1, str_input, str_key); while(p != -1) { substring(str_input, tmp, p, m); printf(\u0026quot;%s\\n\u0026quot;, tmp); p = search(p+n+1, str_input, str_key); } printf(\u0026quot;\\n\u0026quot;); return 0; } void table(char key) { int k, n; n = strlen(key); for(k = 0; k \u0026lt;= 255; k++) skip[k] = n; for(k = 0; k \u0026lt; n - 1; k++) skip[key[k]] = n - k - 1; } int search(int p, char input, char* key) { int i, m, n; char tmp[80] = {\u0026rsquo;\\0\u0026rsquo;}; m = strlen(input); n = strlen(key); while(p \u0026lt; m) { substring(input, tmp, p-n+1, p); if(!strcmp(tmp, key)) // 比较两字串是否相同 return p-n+1; p += skip[input[p]]; } return -1; } void substring(char text, char tmp, int s, int e) { int i, j; for(i = s, j = 0; i \u0026lt;= e; i++, j++) mp[j] = text[i]; tmp[j] = \u0026lsquo;\\0\u0026rsquo;; } 12.Algorithm Gossip: 双色、三色河内塔 说明双色河内塔与三色河内塔是由之前所介绍过的河内塔规则衍生而来，双色河内塔的目的 是将下图左上的圆环位置经移动成为右下的圆环位置： 而三色河内塔则是将下图左上的圆环经移动成为右上的圆环： 解法无论是双色河内塔或是三色河内塔，其解法观念与之前介绍过的河内塔是类似的，同样 也是使用递回来解，不过这次递回解法的目的不同，我们先来看只有两个盘的情况，这很简单， 只要将第一柱的黄色移动至第二柱，而接下来第一柱的蓝色移动至第三柱。 再来是四个盘的情况，首先必须用递回完成下图左上至右下的移动： 接下来最底层的就不用管它们了，因为它们已经就定位，只要再处理第一柱的上面两个盘子就 可以了。那么六个盘的情况呢？一样！首先必须用递回完成下图左上至右下的移动： 接下来最底层的就不用管它们了，因为它们已经就定位，只要再处理第一柱上面的四个盘子就 可以了，这又与之前只有四盘的情况相同，接下来您就知道该如何进行解题了，无论是八个盘、 十个盘以上等，都是用这个观念来解题。 那么三色河内塔呢？一样，直接来看九个盘的情况，首先必须完成下图的移动结果： 接下来最底两层的就不用管它们了，因为它们已经就定位，只要再处理第一柱上面的三个盘子 就可以了。 双色河内塔 C 实作 #include \u0026lt;stdio.h\u0026gt; void hanoi(int disks, char source, char temp, char target) { if (disks == 1) { printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); } else { hanoi(disks-1, source, target, temp); hanoi(1, source, temp, target); hanoi(disks-1, temp, source, target); } } void hanoi2colors(int disks) { char source = \u0026lsquo;A\u0026rsquo;; char temp = \u0026lsquo;B\u0026rsquo;; char target = \u0026lsquo;C\u0026rsquo;; int i; for(i = disks / 2; i \u0026gt; 1; i\u0026ndash;) { hanoi(i-1, source, temp, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); hanoi(i-1, target, temp, source); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, target); } printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); } int main() { int n; printf(\u0026ldquo;请输入盘数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); hanoi2colors(n); return 0; } 三色河内塔 C 实作 #include \u0026lt;stdio.h\u0026gt; void hanoi(int disks, char source, char temp, char target) { if (disks == 1) { printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); } else { hanoi(disks-1, source, target, temp); hanoi(1, source, temp, target); hanoi(disks-1, temp, source, target); } } void hanoi3colors(int disks) { char source = \u0026lsquo;A\u0026rsquo;; char temp = \u0026lsquo;B\u0026rsquo;; char target = \u0026lsquo;C\u0026rsquo;; int i; if(disks == 3) { printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, source); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, target, temp);; } else { hanoi(disks/3-1, source, temp, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); hanoi(disks/3-1, target, temp, source); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, temp, target); hanoi(disks/3-1, source, target, temp); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, target, source); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, target, source); hanoi(disks/3-1, temp, source, target); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); for (i = disks / 3 - 1; i \u0026gt; 0; i\u0026ndash;) { if (i\u0026gt;1) { hanoi(i-1, target, source, temp); } printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;,target, source); printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;,target, source); if (i\u0026gt;1) { hanoi(i-1, temp, source, target); } printf(\u0026ldquo;move disk from %c to %c\\n\u0026rdquo;, source, temp); } } } int main() { int n; printf(\u0026ldquo;请输入盘数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); hanoi3colors(n); return 0; } 13.Algorithm Gossip: 背包问题（Knapsack Problem） 说明假设有一个背包的负重最多可达8公斤，而希望在背包中装入负重范围内可得之总价物 品，假设是水果好了，水果的编号、单价与重量如下所示：\n0 1 2 3\n李子 苹果 橘子 草莓\n4KG 5KG 2KG 1KG\nNT$4500 NT$5700 NT$2250 NT$1100 4\n甜瓜\n6KG\nNT$6700\n解法 背包问题是关于最佳化的问题，要解最佳化问题可以使用「动态规划」（Dynamic programming），从空集合开始，每增加一个元素就先求出该阶段的最佳解，直到所有的元素加 入至集合中，最后得到的就是最佳解。 以背包问题为例，我们使用两个阵列value与item，value表示目前的最佳解所得之总价，item表 示最后一个放至背包的水果，假设有负重量 1～8的背包8个，并对每个背包求其最佳解。 逐步将水果放入背包中，并求该阶段的最佳解： 放入李子\n背\n1\n2\n3\n4\n5\n6\n7\n8\n包 负 重\nvalu\n０\n０\n０\n450\n450\n450\n450\n900\ne\n0\n0\n0\n0\n0\nitem\n－\n－\n－\n０\n０\n０\n０\n０\n放入苹果\n背\n1\n2\n3\n4\n5\n6\n7\n8\n包 负 重\nvalu\n０\n０\n０\n450\n570\n570\n570\n900\ne\n0\n0\n0\n0\n0\nitem\n－\n－\n－\n０\n1\n1\n1\n０\n放入橘子\n背\n1\n2\n3\n4\n5\n6\n7\n8\n包 负 重\nvalu e item\n０ －\n225 0 2\n225 0 2\n450 0 ０\n570 0 1\n675 0 2\n795 0 2\n900 0 ０\n放入草莓 背\n1\n2\n3\n4\n5\n6\n7\n8\n包 负 重\nvalu e item\n110 0 3\n225 0 2\n335 0 3\n450 0 ０\n570 0 1\n680 0 3\n795 0 2\n905 0 3\n放入甜瓜\n背\n1\n2\n3\n4\n5\n6\n7\n8\n包 负 重\nvalu e item\n110 0 3\n225 0 2\n335 0 3\n450 0 ０\n570 0 1\n680 0 3\n795 0 2\n905 0 3\n由最后一个表格，可以得知在背包负重8公斤时，最多可以装入9050元的水果，而最后一个装入 的 水果是3号，也就是草莓，装入了草莓，背包只能再放入7公斤（8-1）的水果，所以必须看 背包负重7公斤时的最佳解，最后一个放入的是2号，也就 是橘子，现在背包剩下负重量5公斤 （7-2），所以看负重 5公斤的最佳解，最后放入的是1号，也就是苹果，此时背包负重量剩下0公 斤（5-5）， 无 法 再放入水果，所以求出最佳解为放入草莓、橘子与苹果，而总价为9050元。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;\n#define LIMIT 8 #define N 5 #define MIN 1 struct body { char name[20]; int size; int price; };\n// 重量限制 // 物品种类 // 最小重量 typedef struct body object; int main(void) { int item[LIMIT+1] = {0}; int value[LIMIT+1] = {0}; int newvalue, i, s, p; object a[] = {{\u0026ldquo;李子\u0026rdquo;, 4, 4500}, {\u0026ldquo;苹果\u0026rdquo;, 5, 5700}, {\u0026ldquo;橘子\u0026rdquo;, 2, 2250}, {\u0026ldquo;草莓\u0026rdquo;, 1, 1100}, {\u0026ldquo;甜瓜\u0026rdquo;, 6, 6700}}; for(i = 0; i \u0026lt; N; i++) { for(s = a[i].size; s \u0026lt;= LIMIT; s++) { p = s - a[i].size; newvalue = value[p] + a[i].price; if(newvalue \u0026gt; value[s]) {// 找到阶段最佳解 value[s] = newvalue; item[s] = i; } } } printf(\u0026ldquo;物品\\t价格\\n\u0026rdquo;); for(i = LIMIT; i \u0026gt;= MIN; i = i - a[item[i]].size) { printf(\u0026quot;%s\\t%d\\n\u0026quot;, a[item[i]].name, a[item[i]].price); } printf(\u0026ldquo;合计\\t%d\\n\u0026rdquo;, value[LIMIT]); return 0; } Java class Fruit { private String name; private int size; private int price; public Fruit(String name, int size, int price) { this.name = name; this.size = size; this.price = price; } public String getName() { return name; } public int getPrice() { return price; } public int getSize() { return size; } } public class Knapsack { public static void main(String[] args) { final int MAX = 8; final int MIN = 1; int[] item = new int[MAX+1]; int[] value = new int[MAX+1]; Fruit fruits[] = { new Fruit(\u0026ldquo;李子\u0026rdquo;, 4, 4500), new Fruit(\u0026ldquo;苹果\u0026rdquo;, 5, 5700), new Fruit(\u0026ldquo;橘子\u0026rdquo;, 2, 2250), new Fruit(\u0026ldquo;草莓\u0026rdquo;, 1, 1100), new Fruit(\u0026ldquo;甜瓜\u0026rdquo;, 6, 6700)}; for(int i = 0; i \u0026lt; fruits.length; i++) { for(int s = fruits[i].getSize(); s \u0026lt;= MAX; s++) { int p = s - fruits[i].getSize(); int newvalue = value[p] + fruits[i].getPrice(); if(newvalue \u0026gt; value[s]) {// 找到阶段最佳解 value[s] = newvalue; item[s] = i; } } } System.out.println(\u0026ldquo;物品\\t价格\u0026rdquo;); for(int i = MAX; i \u0026gt;= MIN; i = i - fruits[item[i]].getSize()) { System.out.println(fruits[item[i]].getName()+ \u0026ldquo;\\t\u0026rdquo; + fruits[item[i]].getPrice()); } System.out.println(\u0026ldquo;合计\\t\u0026rdquo; + value[MAX]); } } 14.Algorithm Gossip: 蒙地卡罗法求 PI 说明蒙地卡罗为摩洛哥王国之首都，该国位于法国与义大利国境，以赌博闻名。蒙地卡罗的 基本原理为以乱数配合面积公式来进行解题，这种以机率来解题的方式带有赌博的意味，虽然 在精确度上有所疑虑，但其解题的思考方向却是个值得学习的方式。 解法蒙地卡罗的解法适用于与面积有关的题目，例如求PI值或椭圆面积，这边介绍如何求PI 值；假设有一个圆半径为1，所以四分之一圆面积就为PI，而包括此四分之一圆的正方形面积就 为1，如下图所示： 如果随意的在正方形中投射飞标（点）好了，则这些飞标（点）有些会落于四分之一圆内，假 设所投射的飞标（点）有n点，在圆内的飞标（点）有c点，则依比例来算，就会得到上图中最 后的公式。 至于如何判断所产生的点落于圆内，很简单，令乱数产生X与Y两个数值，如果X^2+Y^2等于1 就是落在圆内。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define N 50000 int main(void) { int i, sum = 0; double x, y; srand(time(NULL)); for(i = 1; i \u0026lt; N; i++) { x = (double) rand() / RAND_MAX; y = (double) rand() / RAND_MAX; if((x * x + y * y) \u0026lt; 1) sum++; } printf(\u0026ldquo;PI = %f\\n\u0026rdquo;, (double) 4 * sum / N); return 0; } 15.Algorithm Gossip: Eratosthenes 筛选求质数 说明除了自身之外，无法被其它整数整除的数称之为质数，要求质数很简单，但如何快速的 求出质数则一直是程式设计人员与数学家努力的课题，在这边介绍一个着名的 Eratosthenes求质 数方法。 解法首先知道这个问题可以使用回圈来求解，将一个指定的数除以所有小于它的数，若可以 整除就不是质数，然而如何减少回圈的检查次数？如何求出小于N的所有质数？ 首先假设要检查的数是N好了，则事实上只要检查至N的开根号就可以了，道理很简单，假设 AB = N，如果A大于N的开根号，则事实上在小于A之前的检查就可以先检查到B这个数可以整 除N。不过在程式中使用开根号会精确度的问题，所以可以使用 ii \u0026lt;= N进行检查，且执行更快 。 再来假设有一个筛子存放1～N，例如：\n2\n3 4 5\n6 7\n8\n9 10\n11 12\n13 14 15\n16 17\n18 19\n20 21 \u0026hellip;\u0026hellip;.. N\n先将2的倍数筛去：\n2\n3 5 7\n9 11 13 15\n17 19 21 \u0026hellip;\u0026hellip;.. N\n再将3的倍数筛去：\n2\n3 5 7\n11 13\n17 19 \u0026hellip;\u0026hellip;.. N\n再来将5的倍数筛去，再来将7的质数筛去，再来将11的倍数筛去\u0026hellip;\u0026hellip;..，如此进行到最后留下的 数就都是质数，这就是Eratosthenes筛选方法（Eratosthenes Sieve Method）。 检查的次数还可以再减少，事实上，只要检查6n+1与6n+5就可以了，也就是直接跳过2与3的倍 数，使得程式中的if的检查动作可以减少。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 1000 int main(void) { int i, j; int prime[N+1]; for(i = 2; i \u0026lt;= N; i++) prime[i] = 1; for(i = 2; ii \u0026lt;= N; i++) { // 这边可以改进 if(prime[i] == 1) { for(j = 2i; j \u0026lt;= N; j++) { if(j % i == 0) prime[j] = 0; } } } for(i = 2; i \u0026lt; N; i++) { if(prime[i] == 1) { printf(\u0026quot;%4d \u0026ldquo;, i); if(i % 16 == 0) printf(\u0026quot;\\n\u0026rdquo;); } } printf(\u0026quot;\\n\u0026quot;); return 0; } 16.Algorithm Gossip: 超长整数运算（大数运算） 说明基于记忆体的有效运用，程式语言中规定了各种不同的资料型态，也因此变数所可以表 达的最大整数受到限制，例如123456789123456789这样的 整数就不可能储存在long变数中（例 如C/C++等），我们称这为long数，这边翻为超长整数（避免与资料型态的长整数翻译混淆），或 俗称大数运算。 解法一个变数无法表示超长整数，则就使用多个变数，当然这使用阵列最为方便，假设程式 语言的最大资料型态可以储存至65535的数好了，为了计算方便及符合使用十进位制的习惯，让 每一个阵列元素可以储存四个位数，也就是0到9999的数，例如： 很多人问到如何计算像50!这样的问题，解法就是使用程式中的乘法函式，至于要算到多大，就 看需求了。 由于使用阵列来储存数值，关于数值在运算时的加减乘除等各种运算、位数的进位或借位就必 须自行定义，加、减、乘都是由低位数开始运算，而除法则是由高位数开始运算，这边直接提 供加减乘除运算的函式供作参考，以下的N为阵列长度。 void add(int *a, int *b, int *c) { int i, carry = 0; for(i = N - 1; i \u0026gt;= 0; i\u0026ndash;) { c[i] = a[i] + b[i] + carry; if(c[i] \u0026lt; 10000) carry = 0; else { // 进位 c[i] = c[i] - 10000; carry = 1; } } } void sub(int *a, int *b, int *c) { int i, borrow = 0; for(i = N - 1; i \u0026gt;= 0; i\u0026ndash;) { c[i] = a[i] - b[i] - borrow; if(c[i] \u0026gt;= 0) borrow = 0; else { // 借位 c[i] = c[i] + 10000; borrow = 1; } } } void mul(int *a, int b, int *c) { // b 为乘数 int i, tmp, carry = 0; for(i = N - 1; i \u0026gt;=0; i\u0026ndash;) { tmp = a[i] * b + carry; c[i] = tmp % 10000; carry = tmp / 10000; } } void div(int *a, int b, int *c) { // b 为除数 int i, tmp, remain = 0; for(i = 0; i \u0026lt; N; i++) { tmp = a[i] + remain; c[i] = tmp / b; remain = (tmp % b) * 10000; } } 17.Algorithm Gossip: 长 PI 说明圆周率后的小数位数是无止境的，如何使用电脑来计算这无止境的小数是一些数学家与 程式设计师所感兴趣的，在这边介绍一个公式配合 大数运算，可以计算指定位数的圆周率。 解法首先介绍J.Marchin的圆周率公式： 3 5 7 3 5 7 可以将这个公式整理为： 3 3 5 5 也就是说第n项，若为奇数则为正数，为偶数则为负数，而项数表示方式为：\n[16/5\n2*n-1\n2*n-1\n2*n-1\n2n-1 2n-1\n2*n-1\n来的\n大，具有决定性，所以表示至少必须计算至第n项：\n[16/5\n2*n-1\n] / (2*n-1) = 10\n-L\n将上面的等式取log并经过化简，我们可以求得： n = L / (2log5) = L / 1.39794 所以若要求精确度至小数后L位数，则只要求至公式的第n项，其中n等于： n = [L/1.39794] + 1 在上式中[]为高斯符号，也就是取至整数（不大于L/1.39794的整数）；为了计简方便，可以在程 式中使用下面这个公式来计简第n项： 2 2 这个公式的演算法配合大数运算函式的演算法为： div(w, 25, w); div(v, 239, v); div(v, 239, v); sub(w, v, q); div(q, 2k-1, q) 至于大数运算的演算法，请参考之前的文章，必须注意的是在输出时，由于是输出阵列中的整 数值，如果阵列中整数位数不满四位，则必须补上0，在C语言中只要 使用格式指定字%04d， 使得不足位数部份自动补上0再输出，至于Java的部份，使用 NumberFormat来作格式化。 #include \u0026lt;stdio.h\u0026gt; #define L 1000 #define N L/4+1 // L 为位数，N是array长度 void add(int, int*, int*); void sub(int*, int*, int*); void div(int*, int, int*); int main(void) { int s[N+3] = {0}; int w[N+3] = {0}; int v[N+3] = {0}; int q[N+3] = {0}; int n = (int)(L/1.39793 + 1); int k; w[0] = 165; v[0] = 4239; for(k = 1; k \u0026lt;= n; k++) { // 套用公式 div(w, 25, w); div(v, 239, v); div(v, 239, v); sub(w, v, q); div(q, 2*k-1, q); if(k%2) // 奇数项 add(s, q, s);\nelse\n// 偶数项\nsub(s, q, s); } printf(\u0026quot;%d.\u0026quot;, s[0]); for(k = 1; k \u0026lt; N; k++) printf(\u0026quot;%04d\u0026quot;, s[k]); printf(\u0026quot;\\n\u0026quot;); return 0; } void add(int a, int b, int c) { int i, carry = 0; for(i = N+1; i \u0026gt;= 0; i\u0026ndash;) { c[i] = a[i] + b[i] + carry; if(c[i] \u0026lt; 10000) carry = 0; else { // 进位 c[i] = c[i] - 10000; carry = 1; } } } void sub(int a, int b, int c) { int i, borrow = 0; for(i = N+1; i \u0026gt;= 0; i\u0026ndash;) { c[i] = a[i] - b[i] - borrow; if(c[i] \u0026gt;= 0) borrow = 0; else { // 借位 c[i] = c[i] + 10000; borrow = 1; } } } void div(int a, int b, int c) { // b 为除数 int i, tmp, remain = 0; for(i = 0; i \u0026lt;= N+1; i++) { tmp = a[i] + remain; c[i] = tmp / b; remain = (tmp % b) * 10000; } } 18.Algorithm Gossip: 最大公因数、最小公倍数、因式分解 说明最大公因数使用辗转相除法来求，最小公倍数则由这个公式来求： GCD * LCM = 两数乘积 解法最大公因数可以使用递回与非递回求解，因式分解基本上就是使用小于输入数的数值当 作除数，去除以输入数值，如果可以整除就视为因数，要比较快的解法就是求出小于该数的所 有质数，并试试看是不是可以整除，求质数的问题是另一个课题，请参考 Eratosthenes 筛选求 质数。 实作（最大公因数、最小公倍数） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int m, n, r; int s; printf(\u0026ldquo;输入两数：\u0026rdquo;); scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;m, \u0026amp;n); s = m * n; while(n != 0) { r = m % n; m = n; n = r; } printf(\u0026ldquo;GCD：%d\\n\u0026rdquo;, m); printf(\u0026ldquo;LCM：%d\\n\u0026rdquo;, s/m); return 0; } 实作（因式分解） C（不用质数表） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int i, n; printf(\u0026ldquo;请输入整数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); printf(\u0026quot;%d = \u0026ldquo;, n); for(i = 2; i * i \u0026lt;= n;) { if(n % i == 0) { printf(\u0026quot;%d * \u0026ldquo;, i); n /= i; } else i++; } printf(\u0026quot;%d\\n\u0026rdquo;, n); return 0; } C（使用质数表） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 1000 int prime(int); // 求质数表 void factor(int, int); // 求factor int main(void) { int ptable[N+1] = {0}; int count, i, temp; count = prime(ptable); printf(\u0026ldquo;请输入一数：\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;temp); factor(ptable, temp); printf(\u0026quot;\\n\u0026quot;); return 0; } int prime(int pNum) { int i, j; int prime[N+1]; for(i = 2; i \u0026lt;= N; i++) prime[i] = 1; for(i = 2; ii \u0026lt;= N; i++) { if(prime[i] == 1) { for(j = 2i; j \u0026lt;= N; j++) { if(j % i == 0) prime[j] = 0; } } } for(i = 2, j = 0; i \u0026lt; N; i++) { if(prime[i] == 1) pNum[j++] = i; } return j; } void factor(int table, int num) { int i; for(i = 0; table[i] * table[i] \u0026lt;= num;) { if(num % table[i] == 0) { printf(\u0026quot;%d * \u0026ldquo;, table[i]); num /= table[i]; } else i++; } printf(\u0026quot;%d\\n\u0026rdquo;, num); } 19.Algorithm Gossip: 完美数 说明如果有一数n，其真因数（Proper factor）的总和等于n，则称之为完美数（Perfect Number）， 例如以下几个数都是完美数： 6 = 1 + 2 + 3 28 = 1 + 2 + 4 + 7 + 14 496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248 程式基本上不难，第一眼看到时会想到使用回圈求出所有真因数，再进一步求因数和，不过若n 值很大，则此法会花费许多时间在回圈测试上，十分没有效率，例如求小于10000的所有完美数 。 解法如何求小于10000的所有完美数？并将程式写的有效率？基本上有三个步骤： 求出一定数目的质数表 利用质数表求指定数的因式分解 利用因式分解求所有真因数和，并检查是否为完美数 步骤一 与 步骤二 在之前讨论过了，问题在步骤三，如何求真因数和？方法很简单，要先知道 将所有真因数和加上该数本身，会等于该数的两倍，例如： 2 * 28 = 1 + 2 + 4 + 7 + 14 + 28 等式后面可以化为： 0 1 2 0 1 所以只要求出因式分解，就可以利用回圈求得等式后面的值，将该值除以2就是真因数和了；等 式后面第一眼看时可能想到使用等比级数公式来解，不过会使用到次方运算，可以在回圈走访 因式分解阵列时，同时计算出等式后面的值，这在下面的实作中可以看到。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 1000 #define P 10000 int prime(int); // 求质数表 int factor(int, int, int*); // 求factor int fsum(int*, int); // sum ot proper factor int main(void) { int ptable[N+1] = {0}; // 储存质数表\nint fact[N+1] = {0};\n// 储存因式分解结果\nint count1, count2, i; count1 = prime(ptable); for(i = 0; i \u0026lt;= P; i++) { count2 = factor(ptable, i, fact); if(i == fsum(fact, count2)) printf(\u0026ldquo;Perfect Number: %d\\n\u0026rdquo;, i); } printf(\u0026quot;\\n\u0026quot;); return 0; } int prime(int* pNum) { int i, j; int prime[N+1]; for(i = 2; i \u0026lt;= N; i++) prime[i] = 1; for(i = 2; ii \u0026lt;= N; i++) { if(prime[i] == 1) { for(j = 2i; j \u0026lt;= N; j++) { if(j % i == 0) prime[j] = 0; } } } for(i = 2, j = 0; i \u0026lt; N; i++) { if(prime[i] == 1) pNum[j++] = i; } return j; } int factor(int* table, int num, int* frecord) { int i, k; for(i = 0, k = 0; table[i] * table[i] \u0026lt;= num;) { if(num % table[i] == 0) { frecord[k] = table[i]; k++; num /= table[i]; } else i++; } frecord[k] = num; return k+1; } int fsum(int* farr, int c) { int i, r, s, q; i = 0; r = 1; s = 1; q = 1; while(i \u0026lt; c) { do { r = farr[i]; q += r; i++; } while(i \u0026lt; c-1 \u0026amp;\u0026amp; farr[i-1] == farr[i]); s = q; r = 1; q = 1; } return s / 2; } 20.Algorithm Gossip: 阿姆斯壮数 说明 3 3 3 程式找出所有的三位数Armstrong数。 解法 Armstrong数的寻找，其实就是在问如何将一个数字分解为个位数、十位数、百位数\u0026hellip;\u0026hellip;，这只 要使用除法与余数运算就可以了，例如输入 input为abc，则： a = input / 100 b = (input%100) / 10 c = input % 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main(void) { int a, b, c; int input; printf(\u0026ldquo;寻找Armstrong数：\\n\u0026rdquo;); for(input = 100; input \u0026lt;= 999; input++) { a = input / 100; b = (input % 100) / 10; c = input % 10; if(aaa + bbb + ccc == input) printf(\u0026quot;%d \u0026ldquo;, input); } printf(\u0026quot;\\n\u0026rdquo;); return 0; } 21.Algorithm Gossip: 最大访客数 说明 现将举行一个餐会，让访客事先填写到达时间与离开时间，为了掌握座位的数目，必须先估计 不同时间的最大访客数。 解法 这个题目看似有些复杂，其实相当简单，单就计算访客数这个目的，同时考虑同一访客的来访 时间与离开时间，反而会使程式变得复杂；只要将来访时间与离开时间分开处理就可以了，假 设访客 i 的来访时间为x[i]，而离开时间为y[i]。 在资料输入完毕之后，将x[i]与y[i]分别进行排序（由小到大），道理很简单，只要先计算某时之 前总共来访了多少访客，然后再减去某时之前的离开访客，就可以轻易的解出这个问题。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX 100 #define SWAP(x,y) {int t; t = x; x = y; y = t;} int partition(int[], int, int); void quicksort(int[], int, int); // 快速排序法 int maxguest(int[], int[], int, int); int main(void) { int x[MAX] = {0}; int y[MAX] = {0}; int time = 0; int count = 0; printf(\u0026quot;\\n输入来访与离开125;时间(0~24)：\u0026quot;); printf(\u0026quot;\\n范例：10 15\u0026quot;); printf(\u0026quot;\\n输入-1 -1结束\u0026quot;); while(count \u0026lt; MAX) { printf(\u0026quot;\\n\u0026raquo;\u0026quot;); scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x[count], \u0026amp;y[count]); if(x[count] \u0026lt; 0) break; count++; } if(count \u0026gt;= MAX) { printf(\u0026quot;\\n超出最大访客数(%d)\u0026quot;, MAX); count\u0026ndash;; } // 预先排序 quicksort(x, 0, count); quicksort(y, 0, count); while(time \u0026lt; 25) { printf(\u0026quot;\\n%d 时的最大访客数：%d\u0026quot;, time, maxguest(x, y, count, time)); time++; } printf(\u0026quot;\\n\u0026quot;); return 0; } int maxguest(int x[], int y[], int count, int time) { int i, num = 0; for(i = 0; i \u0026lt;= count; i++) { if(time \u0026gt; x[i]) num++; if(time \u0026gt; y[i]) num\u0026ndash;; } return num; } int partition(int number[], int left, int right) { int i, j, s; s = number[right]; i = left - 1; for(j = left; j \u0026lt; right; j++) { if(number[j] \u0026lt;= s) { i++; SWAP(number[i], number[j]); } } SWAP(number[i+1], number[right]); return i+1; } void quicksort(int number[], int left, int right) { int q; if(left \u0026lt; right) { q = partition(number, left, right); quicksort(number, left, q-1); quicksort(number, q+1, right); } } 22.Algorithm Gossip: 中序式转后序式（前序式） 说明平常所使用的运算式，主要是将运算元放在运算子的两旁，例如a+b/d这样的式子，这称 之为中序（Infix）表示式，对于人类来说，这样的式子很容易理 解，但由于电脑执行指令时是 有顺序的，遇到中序表示式时，无法直接进行运算，而必须进一步判断运算的先后顺序，所以 必须将中序表示式转换为另一种表示方 法。 可以将中序表示式转换为后序（Postfix）表示式，后序表示式又称之为逆向波兰表示式（Reverse polish notation），它是由波兰的数学家卢卡谢维奇提出，例如(a+b)(c+d)这个式子，表示为后序 表示式时是ab+cd+。 解法用手算的方式来计算后序式相当的简单，将运算子两旁的运算元依先后顺序全括号起来， 然后将所有的右括号取代为左边最接近的运算子（从最内层括号开始），最后去掉所有的左括号 就可以完成后序表示式，例如：\na+b*d+c/d\n=\u0026gt; ((a+(bd))+(c/d)) -\u0026gt; bd+cd/+\n如果要用程式来进行中序转后序，则必须使用堆叠，演算法很简单，直接叙述的话就是使用回 圈，取出中序式的字元，遇运算元直接输出，堆叠运算子与左括号， ISP\u0026gt;ICP的话直接输出堆 叠中的运算子，遇右括号输出堆叠中的运算子至左括号。\n例 如 (a+b)*(c+d) 这个式子，依演算 法的输出过程如 下： OP ( a + b ) * ( c + d ) STACK ( ( (+ (+        OUTPUT a a ab ab+ ab+ ab+ ab+c ab+c ab+cd ab+cd+ ab+cd+*\n如果要将中序式转为前序式，则在读取中序式时是由后往前读取，而左右括号的处理方式相反， 其余不变，但输出之前必须先置入堆叠，待转换完成后再将堆叠中的 值由上往下读出，如此就 是前序表示式。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int postfix(char*); // 中序转后序 int priority(char); // 决定运算子优先顺序 int main(void) { char input[80]; printf(\u0026ldquo;输入中序运算式：\u0026rdquo;); scanf(\u0026quot;%s\u0026quot;, input); postfix(input); return 0; } int postfix(char* infix) { int i = 0, top = 0; char stack[80] = {\u0026rsquo;\\0\u0026rsquo;}; char op; while(1) { op = infix[i]; switch(op) { case \u0026lsquo;\\0\u0026rsquo;: while(top \u0026gt; 0) { printf(\u0026quot;%c\u0026quot;, stack[top]); top\u0026ndash;; } printf(\u0026quot;\\n\u0026quot;); return 0; // 运算子堆叠 case \u0026lsquo;(\u0026rsquo;: if(top \u0026lt; (sizeof(stack) / sizeof(char))) { top++; stack[top] = op; } break; case \u0026lsquo;+\u0026rsquo;: case \u0026lsquo;-\u0026rsquo;: case \u0026lsquo;\u0026rsquo;: case \u0026lsquo;/\u0026rsquo;: while(priority(stack[top]) \u0026gt;= priority(op)) { printf(\u0026quot;%c\u0026quot;, stack[top]); top\u0026ndash;; } // 存入堆叠 if(top \u0026lt; (sizeof(stack) / sizeof(char))) { top++; stack[top] = op; } break; // 遇 ) 输出至 ( case \u0026lsquo;)\u0026rsquo;: while(stack[top] != \u0026lsquo;(\u0026rsquo;) { printf(\u0026quot;%c\u0026quot;, stack[top]); top\u0026ndash;; } top\u0026ndash;; // 不输出( break; // 运算元直接输出 default: printf(\u0026quot;%c\u0026quot;, op); break; } i++; } } int priority(char op) { int p; switch(op) { case \u0026lsquo;+\u0026rsquo;: case \u0026lsquo;-\u0026rsquo;: p = 1; break; case \u0026lsquo;\u0026rsquo;: case \u0026lsquo;/\u0026rsquo;: p = 2; break; default: p = 0; break; } return p; } 23.Algorithm Gossip: 后序式的运算 说明 将中序式转换为后序式的好处是，不用处理运算子先后顺序问题，只要依序由运算式由 前往后读取即可。 解法\n运算时由后序式的前方开 始读取，遇到运算元先存入 堆叠，如果遇到运算子，则 由堆叠中取出两个运算元进 行对应的运算，然后将结果 存回堆叠，如果运算式读取 完 毕，那么堆叠顶的值就是 答案了，例如我们计算 12+34+这个运算式（也就是 (1+2)(3+4)）： 读取 1 2 + 3 4 + * #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void evalPf(char*); double cal(double, char, double); int main(void) { char input[80];\n堆叠 1 12 3 // 1+2 后存回 33 334 3 7 // 3+4 后存回 21 // 3 * 7 后存回 printf(\u0026ldquo;输入后序式：\u0026rdquo;); scanf(\u0026quot;%s\u0026quot;, input); evalPf(input); return 0; } void evalPf(char* postfix) { double stack[80] = {0.0}; char temp[2]; char token; int top = 0, i = 0; temp[1] = \u0026lsquo;\\0\u0026rsquo;; while(1) { token = postfix[i]; switch(token) { case \u0026lsquo;\\0\u0026rsquo;: printf(\u0026ldquo;ans = %f\\n\u0026rdquo;, stack[top]); return; case \u0026lsquo;+\u0026rsquo;: case \u0026lsquo;-\u0026rsquo;: case \u0026lsquo;\u0026rsquo;: case \u0026lsquo;/\u0026rsquo;: stack[top-1] = cal(stack[top], token, stack[top-1]); top\u0026ndash;; break; default: if(top \u0026lt; sizeof(stack) / sizeof(float)) { temp[0] = postfix[i]; top++; stack[top] = atof(temp); } break; } i++; } } double cal(double p1, char op, double p2) { switch(op) { case \u0026lsquo;+\u0026rsquo;: return p1 + p2; case \u0026lsquo;-\u0026rsquo;: return p1 - p2; case \u0026lsquo;\u0026rsquo;: return p1 * p2; case \u0026lsquo;/\u0026rsquo;: return p1 / p2; } } 24.Algorithm Gossip: 洗扑克牌（乱数排列） 说明 洗扑克牌的原理其实与乱数排列是相同的，都是将一组数字（例如 1～N）打乱重新排列，只 不过洗扑克牌多了一个花色判断的动作而已。 解法 初学者通常会直接想到，随机产生1～N的乱数并将之存入阵列中，后来产生的乱数存入阵列 前必须先检查阵列中是否已有重复的数字，如果有这个数就不存入，再重新产生下一个数，运 气不好的话，重复的次数就会很多，程式的执行速度就很慢了，这不是一个好方法。 以1～52的乱数排列为例好了，可以将阵列先依序由 1到52填入，然后使用一个回圈走访阵列， 并随机产生1～52的乱数，将产生的乱数当作索引取出阵列值，并与目前阵列走访到的值相交换 ， 如此就不用担心乱数重复的问题了，阵列走访完毕后，所有的数字也就重新排列了。 至于如何判断花色？这只是除法的问题而已，取商数判断花色，取余数判断数字，您可以直接 看程式比较清楚。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define N 52 int main(void) { int poker[N + 1]; int i, j, tmp, remain; // 初始化阵列 for(i = 1; i \u0026lt;= N; i++) poker[i] = i; srand(time(0)); // 洗牌 for(i = 1; i \u0026lt;= N; i++) { j = rand() % 52 + 1; tmp = poker[i]; poker[i] = poker[j]; poker[j] = tmp; } for(i = 1; i \u0026lt;= N; i++) { // 判断花色 switch((poker[i]-1) / 13) { case 0: printf(\u0026ldquo;桃\u0026rdquo;); break; case 1: printf(\u0026ldquo;心\u0026rdquo;); break; case 2: printf(\u0026ldquo;砖\u0026rdquo;); break; case 3: printf(\u0026ldquo;梅\u0026rdquo;); break; } // 扑克牌数字 remain = poker[i] % 13; switch(remain) { case 0: printf(\u0026ldquo;K \u0026ldquo;); break; case 12: printf(\u0026ldquo;Q \u0026ldquo;); break; case 11: printf(\u0026ldquo;J \u0026ldquo;); break; default: printf(\u0026quot;%d \u0026ldquo;, remain); break; } if(i % 13 == 0) printf(\u0026quot;\\n\u0026rdquo;); } return 0; } 25.Algorithm Gossip: Craps 赌博游戏 说明一个简单的赌博游戏，游戏规则如下：玩家掷两个骰子，点数为1到6，如果第一次点数 和为7或11，则玩家胜，如果点数和为2、3或12，则玩家输，如果和 为其它点数，则记录第一 次的点数和，然后继续掷骰，直至点数和等于第一次掷出的点数和，则玩家胜，如果在这之前 掷出了点数和为7，则玩家输。\n解法\n规则看来有些复杂，但是其实只要使用switch配合if条件判断来撰写即可，小心不要弄\n错胜负顺序即可。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define WON 0 #define LOST 1 #define CONTINUE 2 int rollDice() { return (rand() % 6) + (rand() % 6) + 2; } int main(void) { int firstRoll = 1; int gameStatus = CONTINUE; int die1, die2, sumOfDice; int firstPoint = 0; char c; srand(time(0)); printf(\u0026ldquo;Craps赌博游戏，按Enter键开始游戏****\u0026rdquo;); while(1) { getchar(); if(firstRoll) { sumOfDice = rollDice(); printf(\u0026quot;\\n玩家掷出点数和：%d\\n\u0026rdquo;, sumOfDice); switch(sumOfDice) { case 7: case 11: gameStatus = WON; break; case 2: case 3: case 12: gameStatus = LOST; break; default: firstRoll = 0; gameStatus = CONTINUE; firstPoint = sumOfDice; break; } } else { sumOfDice = rollDice(); printf(\u0026quot;\\n玩家掷出点数和：%d\\n\u0026rdquo;, sumOfDice); if(sumOfDice == firstPoint) gameStatus = WON; else if(sumOfDice == 7) gameStatus = LOST; } if(gameStatus == CONTINUE) puts(\u0026ldquo;未分胜负，再掷一次****\\n\u0026rdquo;); else { if(gameStatus == WON) puts(\u0026ldquo;玩家胜\u0026rdquo;); else puts(\u0026ldquo;玩家输\u0026rdquo;); printf(\u0026ldquo;再玩一次？\u0026rdquo;); scanf(\u0026quot;%c\u0026rdquo;, \u0026amp;c); if(c == \u0026rsquo;n\u0026rsquo;) { puts(\u0026ldquo;游戏结束\u0026rdquo;); break; } firstRoll = 1; } } return 0; } 26.Algorithm Gossip: 约瑟夫问题（Josephus Problem）\n说明据说着名犹太历史学家\nJosephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹\n太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人到，于是决定了 一个自杀方式，41个人排成一个圆圈，由第1个人 开始报数，每报数到第3人该人就必须自杀， 然后再由下一个重新报数，直到所有人都自杀身亡为止。 然而Josephus 和他的朋友并不想遵从，Josephus要他的朋友先假装遵从，他将朋友与自己安排 在第16个与第31个位置，于是逃过了这场死亡游戏。 解法约瑟夫问题可用代数分析来求解，将这个问题扩大好了，假设现在您与m个朋友不幸参 与了这个游戏，您要如何保护您与您的朋友？只要画两个圆圈就可以让自己与朋友免于死亡游 戏，这两个圆圈内圈是排列顺序，而外圈是自杀顺序，如下图所示： 使用程式来求解的话，只要将阵列当作环状来处理就可以了，在阵列中由计数1开始，每找到三 个无资料区就填入一个计数，直而计数达41为止，然后将阵列由索引1开始列出，就可以得知每 个位置的自杀顺序，这就是约瑟夫排列，41个人而报数3的约琴夫排列如下所示： 14 36 1 38 15 2 24 30 3 16 34 4 25 17 5 40 31 6 18 26 7 37 19 8 35 27 9 20 32 10 41 21 11 28 39 12 22 33 13 29 23 由上可知，最后一个自杀的是在第31个位置，而倒数第二个自杀的要排在第16个位置，之前的 人都死光了，所以他们也就不知道约琴夫与他的朋友并没有遵守游戏规则了。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 41 #define M 3 int main(void) { int man[N] = {0}; int count = 1; int i = 0, pos = -1; int alive = 0; while(count \u0026lt;= N) { do { pos = (pos+1) % N; // 环状处理 if(man[pos] == 0) i++; if(i == M) { // 报数为3了 i = 0; break; } } while(1); man[pos] = count; count++; } printf(\u0026quot;\\n约琴夫排列：\u0026rdquo;); for(i = 0; i \u0026lt; N; i++) printf(\u0026quot;%d \u0026ldquo;, man[i]); printf(\u0026quot;\\n\\n您想要救多少人？\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;alive); printf(\u0026quot;\\nL表示这%d人要放的位置：\\n\u0026rdquo;, alive); for(i = 0; i \u0026lt; N; i++) {\nif(man[i] \u0026gt; alive)\nprintf(\u0026ldquo;D\u0026rdquo;);\nelse\nprintf(\u0026ldquo;L\u0026rdquo;);\nif((i+1) % 5 == 0) printf(\u0026quot;\n\u0026ldquo;);\n} printf(\u0026quot;\\n\u0026rdquo;); return 0; } 27.Algorithm Gossip: 排列组合 说明将一组数字、字母或符号进行排列，以得到不同的组合顺序，例如1 2 3这三个数的排列 组合有：1 2 3、1 3 2、2 1 3、2 3 1、3 1 2、3 2 1。 解法可以使用递回将问题切割为较小的单元进行排列组合，例如1 2 3 4的排列可以分为1 [2 3 4]、2 [1 3 4]、3 [1 2 4]、4 [1 2 3]进行排列，这边利用旋转法，先将旋转间隔设为0，将最右边的 数字旋转至最左边，并逐步增加旋转的间隔，例如： 1 2 3 4 -\u0026gt; 旋转1 -\u0026gt; 继续将右边2 3 4进行递回处理 2 1 3 4 -\u0026gt; 旋转1 2 变为 2 1-\u0026gt; 继续将右边1 3 4进行递回处理 3 1 2 4 -\u0026gt; 旋转1 2 3变为 3 1 2 -\u0026gt; 继续将右边1 2 4进行递回处理 4 1 2 3 -\u0026gt; 旋转1 2 3 4变为4 1 2 3 -\u0026gt; 继续将右边1 2 3进行递回处理 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 4 void perm(int*, int); int main(void) { int num[N+1], i; for(i = 1; i \u0026lt;= N; i++) num[i] = i; perm(num, 1); return 0; } void perm(int* num, int i) { int j, k, tmp; if(i \u0026lt; N) { for(j = i; j \u0026lt;= N; j++) { tmp = num[j]; // 旋转该区段最右边数字至最左边 for(k = j; k \u0026gt; i; k\u0026ndash;) num[k] = num[k-1]; num[i] = tmp; perm(num, i+1); // 还原 for(k = i; k \u0026lt; j; k++) num[k] = num[k+1]; num[j] = tmp; } } else { // 显示此次排列 for(j = 1; j \u0026lt;= N; j++) printf(\u0026quot;%d \u0026ldquo;, num[j]); printf(\u0026quot;\\n\u0026rdquo;); } } 28.Algorithm Gossip: 格雷码（Gray Code） 说明 Gray Code是一个数列集合，每个数使用二进位来表示，假设使用n位元来表示每个数好了，任 两个数之间只有一个位元值不同，例如以下为3位元的Gray Code： 000 001 011 010 110 111 101 100 由定义可以知道，Gray Code的顺序并不是唯一的，例如将上面的数列反过来写，也是一组Gray Code： 100 101 111 110 010 011 001 000 Gray Code是由贝尔实验室的Frank Gray在1940年代提出的，用来在使用PCM（Pusle Code Modulation）方法传送讯号时避免出错，并于1953年三月十七日取得美国专利。 解法 由于Gray Code相邻两数之间只改变一个位元，所以可观 察Gray Code从1变0或从0变1时的 位置，假设有4位元的Gray Code如下： 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000 观察奇数项的变化时，我们发现无论它是第几个Gray Code，永远只改变最右边的位元，如果 是1就改为0，如果是0就改为1。 观察偶数项的变化时，我们发现所改变的位元，是由右边算来第一个1的左边位元。 以上两个变化规则是固定的，无论位元数为何；所以只要判断位元的位置是奇数还是偶数，就 可以决定要改变哪一个位元的值，为了程式撰写方便，将阵列索引 0当作最右边的值，而在列 印结果时，是由索引数字大的开始反向列印。 将2位元的Gray Code当作平面座标来看，可以构成一个四边形，您可以发现从任一顶点出发， 绕四边形周长绕一圈，所经过的顶点座标就是一组 Gray Code，所以您可以得到四组 Gray Code。 同样的将3位元的Gray Code当作平面座标来看的话，可以构成一个正立方体，如果您可以从任 一顶点出发，将所有的边长走过，并不重复经过顶点的话，所经过的顶点座标顺序之组合也就 是一组Gray Code。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXBIT 20 #define TRUE 1 #define CHANGE_BIT(x) x = ((x) == \u0026lsquo;0\u0026rsquo; ? \u0026lsquo;1\u0026rsquo; : \u0026lsquo;0\u0026rsquo;) #define NEXT(x) x = (1 - (x)) int main(void) { char digit[MAXBIT]; int i, bits, odd; printf(\u0026ldquo;输入位元数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;bits); for(i = 0; i \u0026lt; bits; i++) { digit[i] = \u0026lsquo;0\u0026rsquo;; printf(\u0026ldquo;0\u0026rdquo;); } printf(\u0026quot;\\n\u0026quot;); odd = TRUE; while(1) { if(odd) CHANGE_BIT(digit[0]); else { // 计算第一个1的位置 for(i = 0; i \u0026lt; bits \u0026amp;\u0026amp; digit[i] == \u0026lsquo;0\u0026rsquo;; i++) ; if(i == bits - 1) // 最后一个Gray Code break; CHANGE_BIT(digit[i+1]); } for(i = bits - 1; i \u0026gt;= 0; i\u0026ndash;) printf(\u0026quot;%c\u0026quot;, digit[i]); printf(\u0026quot;\\n\u0026quot;); NEXT(odd); } return 0; } 29.Algorithm Gossip: 产生可能的集合 说明 给定一组数字或符号，产生所有可能的集合（包括空集合）， 例如给定1 2 3，则可能的集合为： {}、{1}、{1,2}、{1,2,3}、{1,3}、{2}、{2,3}、{3}。 解法 如果不考虑字典顺序，则有个简单的方法可以产生所有的集合，思考二进位数字加法，并注意 1出现的位置，如果每个位置都对应一个数字，则由1所对应的数字所产生的就是一个集合，例 如：\n000 001 010 011 100 101 110 111\n{} {3} {2} {2,3} {1} {1,3} {1,2} {1,2,3}\n了解这个方法之后，剩下的就是如何产生二进位数？有许多方法可以使用，您可以使用unsigned 型别加上\u0026amp;位元运算来产生，这边则是使用阵列搜 寻，首先阵列内容全为0，找第一个1，在还 没找到之前将走访过的内容变为0，而第一个找到的0则变为 1，如此重复直到所有的阵列元素 都变为1为止，例如： 000 =\u0026gt; 100 =\u0026gt; 010 =\u0026gt; 110 =\u0026gt; 001 =\u0026gt; 101 =\u0026gt; 011 =\u0026gt; 111 如果要产生字典顺序，例如若有4个元素，则： {} =\u0026gt; {1} =\u0026gt; {1,2} =\u0026gt; {1,2,3} =\u0026gt; {1,2,3,4} =\u0026gt; {1,2,4} =\u0026gt; {1,3} =\u0026gt; {1,3,4} =\u0026gt; {1,4} =\u0026gt; {2} =\u0026gt; {2,3} =\u0026gt; {2,3,4} =\u0026gt; {2,4} =\u0026gt; {3} =\u0026gt; {3,4} =\u0026gt; {4} 简单的说，如果有n个元素要产生可能的集合，当依序产生集合时，如果最后一个元素是n，而 倒数第二个元素是m的话，例如： {a b c d e n} 则下一个集合就是{a b c d e+1}，再依序加入后续的元素。 例如有四个元素，而当产生{1 2 3 4}集合时，则下一个集合就是{1 2 3+1}，也就是{1 2 4}，由于 最后一个元素还是4，所以下一个集合就是{1 2+1}，也就是{1 3}，接下来再加入后续元素4，也 就是{1 3 4}，由于又遇到元素4，所以下一个集合是{1 3+1}，也就是{1 4}。 实作 C（无字典顺序） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXSIZE 20 int main(void) { char digit[MAXSIZE]; int i, j; int n; printf(\u0026ldquo;输入集合个数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for(i = 0; i \u0026lt; n; i++) digit[i] = \u0026lsquo;0\u0026rsquo;; printf(\u0026quot;\\n{}\u0026quot;); // 空集合 while(1) { // 找第一个0，并将找到前所经过的元素变为0 for(i = 0; i \u0026lt; n \u0026amp;\u0026amp; digit[i] == \u0026lsquo;1\u0026rsquo;; digit[i] = \u0026lsquo;0\u0026rsquo;, i++); if(i == n) // 找不到0 break;\nelse\n// 将第一个找到的0变为1 digit[i] = \u0026lsquo;1\u0026rsquo;; // 找第一个1，并记录对应位置 for(i = 0; i \u0026lt; n \u0026amp;\u0026amp; digit[i] == \u0026lsquo;0\u0026rsquo;; i++); printf(\u0026quot;\\n{%d\u0026quot;, i+1); for(j = i + 1; j \u0026lt; n; j++) if(digit[j] == \u0026lsquo;1\u0026rsquo;) printf(\u0026quot;,%d\u0026quot;, j + 1); printf(\u0026quot;}\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); return 0; } C（字典顺序） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXSIZE 20 int main(void) { int set[MAXSIZE]; int i, n, position = 0; printf(\u0026ldquo;输入集合个数：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); printf(\u0026quot;\\n{}\u0026quot;); set[position] = 1; while(1) { printf(\u0026quot;\\n{%d\u0026quot;, set[0]); // 印第一个数 for(i = 1; i \u0026lt;= position; i++) printf(\u0026quot;,%d\u0026quot;, set[i]); printf(\u0026quot;}\u0026quot;); if(set[position] \u0026lt; n) { // 递增集合个数 set[position+1] = set[position] + 1; position++; } else if(position != 0) { // 如果不是第一个位置\nposition\u0026ndash;;\n// 倒退\nset[position]++; // 下一个集合尾数 } else // 已倒退至第一个位置 break; } printf(\u0026quot;\\n\u0026quot;); return 0; } 30.Algorithm Gossip: m 元素集合的 n 个元素子集 说明 假设有个集合拥有m个元素，任意的从集合中取出n个元素，则这n个元素所形成的可能子集有 那些？ 解法 假设有5个元素的集点，取出3个元素的可能子集如下： {1 2 3}、{1 2 4 }、{1 2 5}、{1 3 4}、{1 3 5}、{1 4 5}、{2 3 4}、{2 3 5}、{2 4 5}、 {3 4 5} 这些子集已经使用字典顺序排列，如此才可以观察出一些规则： 如果最右一个元素小于m，则如同码表一样的不断加1 如果右边一位已至最大值，则加1的位置往左移 每次加1的位置往左移后，必须重新调整右边的元素为递减顺序 所以关键点就在于哪一个位置必须进行加1的动作，到底是最右一个位置要加1？还是其它的位 置？ 在实际撰写程式时，可以使用一个变数positon来记录加1的位置，position的初值设定为n-1， 因为我们要使用阵列，而最右边的索引值为最大 的n-1，在position位置的值若小于m就不断加 1，如果大于m了，position就减1，也就是往左移一个位置；由于位置左移后，右边的元素会 经 过调整，所以我们必须检查最右边的元素是否小于 m，如果是，则position调整回n-1，如果不 是，则positon维持不变。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX 20 int main(void) { int set[MAX]; int m, n, position; int i; printf(\u0026ldquo;输入集合个数 m：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); printf(\u0026ldquo;输入取出元素 n：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for(i = 0; i \u0026lt; n; i++) set[i] = i + 1; // 显示第一个集合 for(i = 0; i \u0026lt; n; i++) printf(\u0026quot;%d \u0026ldquo;, set[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); position = n - 1; while(1) { if(set[n-1] == m) position\u0026ndash;; else position = n - 1; set[position]++; // 调整右边元素 for(i = position + 1; i \u0026lt; n; i++) set[i] = set[i-1] + 1; for(i = 0; i \u0026lt; n; i++) printf(\u0026quot;%d \u0026ldquo;, set[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); if(set[0] \u0026gt;= m - n + 1) break; } return 0; } 31.Algorithm Gossip: 数字拆解 说明 这个题目来自于 数字拆解，我将之改为C语言的版本，并加上说明。 题目是这样的： 3 = 2+1 = 1+1+1 所以3有三种拆法 4 = 3 + 1 = 2 + 2 = 2 + 1 + 1 = 1 + 1 + 1 + 1 共五种 5 = 4 + 1 = 3 + 2 = 3 + 1 + 1 = 2 + 2 + 1 = 2 + 1 + 1 + 1 = 1 + 1 +1 +1 +1 共七种 依此类推，请问一个指定数字NUM的拆解方法个数有多少个？ 解法 我们以上例中最后一个数字5的拆解为例，假设f( n )为数字n的可拆解方式个数，而f(x, y)为使 用y以下的数字来拆解x的方法个数，则观察： 5 = 4 + 1 = 3 + 2 = 3 + 1 + 1 = 2 + 2 + 1 = 2 + 1 + 1 + 1 = 1 + 1 +1 +1 +1 使用函式来表示的话： f(5) = f(4, 1) + f(3,2) + f(2,3) + f(1,4) + f(0,5) 其中f(1, 4) = f(1, 3) + f(1, 2) + f(1, 1)，但是使用大于1的数字来拆解1没有意义，所以f(1, 4) = f(1, 1)，而同样的，f(0, 5)会等于f(0, 0)，所以： f(5) = f(4, 1) + f(3,2) + f(2,3) + f(1,1) + f(0,0) 依照以上的说明，使用动态程式规画（Dynamic programming）来进行求解，其中f(4,1)其实就 是f(5-1, min(5-1,1))，f(x, y)就等于f(n-y, min(n-x, y))，其中n为要拆解的数字，而min()表示取两 者中较小的数。 使用一个二维阵列表格table[x][y]来表示f(x, y)，刚开始时，将每列的索引0与索引1元素值设定 为1，因为任何数以0以下的数拆解必只有1种，而任何数以1以下的数拆解也必只有1种： for(i = 0; i \u0026lt; NUM +1; i++){ table[i][0] = 1; // 任何数以0以下的数拆解必只有1种 table[i][1] = 1; // 任何数以1以下的数拆解必只有1种 } 接下来就开始一个一个进行拆解了，如果数字为NUM，则我们的阵列维度大小必须为NUM x (NUM/2+1)，以数字10为例，其维度为10 x 6我们的表格将会如下所示： 1 1 0 0 0 0 1 1 0 0 0 0 1 1 2 0 0 0 1 1 2 3 0 0 1 1 3 4 5 0 1 1 3 5 6 7 1 1 4 7 9 0 1 1 4 8 0 0 1 1 5 0 0 0 1 1 0 0 0 0 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;\n#define NUM 10\n// 要拆解的数字\n#define DEBUG 0 int main(void) { int table[NUM][NUM/2+1] = {0}; // 动态规画表格 int count = 0; int result = 0; int i, j, k; printf(\u0026ldquo;数字拆解\\n\u0026rdquo;); printf(\u0026ldquo;3 = 2+1 = 1+1+1 所以3有三种拆法\\n\u0026rdquo;); printf(\u0026ldquo;4 = 3 + 1 = 2 + 2 = 2 + 1 + 1 = 1 + 1 + 1 + 1\u0026rdquo;); printf(\u0026ldquo;共五种\\n\u0026rdquo;); printf(\u0026ldquo;5 = 4 + 1 = 3 + 2 = 3 + 1 + 1\u0026rdquo;); printf(\u0026rdquo; = 2 + 2 + 1 = 2 + 1 + 1 + 1 = 1 + 1 +1 +1 +1\u0026rdquo;); printf(\u0026ldquo;共七种\\n\u0026rdquo;); printf(\u0026ldquo;依此类推，求 %d 有几种拆法？\u0026rdquo;, NUM); // 初始化 for(i = 0; i \u0026lt; NUM; i++){ table[i][0] = 1; // 任何数以0以下的数拆解必只有1种 table[i][1] = 1; // 任何数以1以下的数拆解必只有1种 } // 动态规划 for(i = 2; i \u0026lt;= NUM; i++){ for(j = 2; j \u0026lt;= i; j++){ if(i + j \u0026gt; NUM) // 大于 NUM continue; count = 0; for(k = 1 ; k \u0026lt;= j; k++){ count += table[i-k][(i-k \u0026gt;= k) ? k : i-k]; } table[i][j] = count; } } // 计算并显示结果 for(k = 1 ; k \u0026lt;= NUM; k++) result += table[NUM-k][(NUM-k \u0026gt;= k) ? k : NUM-k]; printf(\u0026quot;\\n\\nresult: %d\\n\u0026quot;, result); if(DEBUG) { printf(\u0026quot;\\n除错资讯\\n\u0026quot;); for(i = 0; i \u0026lt; NUM; i++) { for(j = 0; j \u0026lt; NUM/2+1; j++) printf(\u0026quot;%2d\u0026quot;, table[i][j]); printf(\u0026quot;\\n\u0026quot;); } } return 0; } 32.Algorithm Gossip: 得分排行 说明假设有一教师依学生座号输入考试分数，现希望在输入完毕后自动显示学生分数的排行， 当然学生的分数可能相同。 解法这个问题基本上要解不难，只要使用额外的一个排行阵列走访分数阵列就可以了，直接 使用下面的程式片段作说明： for(i = 0; i \u0026lt; count; i++) { juni[i] = 1; for(j = 0; j \u0026lt; count; j++) { if(score[j] \u0026gt; score[i]) juni[i]++; } } printf(\u0026ldquo;得分\\t排行\\n\u0026rdquo;); for(i = 0; i \u0026lt; count; i++) printf(\u0026quot;%d\\t%d\\n\u0026quot;, score[i], juni[i]); 上面这个方法虽然简单，但是反覆计算的次数是n^2，如果n值变大，那么运算的时间就会拖长； 改变juni阵列的长度为n+2，并将初始值设定为0，如下所示： 接下来走访分数阵列，并在分数所对应的排行阵列索引元素上加1，如下所示： 将排行阵列最右边的元素设定为1，然后依序将右边的元素值加至左边一个元素，最后排行阵列 中的「分数+1」」就是得该分数的排行，如下所示： 这样的方式看起来复杂，其实不过在计算某分数之前排行的人数，假设89分之前的排行人数为x 人，则89分自然就是x+1了，这也是为什么排行阵列最右边要设定为1的原因；如果89分有y人， 则88分自然就是x+y+1，整个阵列右边元素向左加的原因正是如此。 如果分数有负分的情况，由于C/C++或Java等程式语言无法处理负的索引，所以必须加上一个 偏移值，将所有的分数先往右偏移一个范围即可，最后显示的时候记得减回偏移值就可以了。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX 100 #define MIN 0 int main(void) { int score[MAX+1] = {0}; int juni[MAX+2] = {0}; int count = 0, i; do { printf(\u0026ldquo;输入分数，-1结束：\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;score[count++]); } while(score[count-1] != -1); count\u0026ndash;; for(i = 0; i \u0026lt; count; i++) juni[score[i]]++; juni[MAX+1] = 1; for(i = MAX; i \u0026gt;= MIN; i\u0026ndash;) juni[i] = juni[i] + juni[i+1]; printf(\u0026ldquo;得分\\t排行\\n\u0026rdquo;); for(i = 0; i \u0026lt; count; i++) printf(\u0026quot;%d\\t%d\\n\u0026quot;, score[i], juni[score[i]+1]); return 0; } 33.Algorithm Gossip: 选择、插入、气泡排序 说明选择排序（Selection sort）、插入排序（Insertion sort）与气泡排序（Bubble sort）这三个 排序方式是初学排序所必须知道的三个基本排序方式，它们由于速度不快而不实用（平均与最 2 解法 选择排序 将要排序的对象分作两部份，一个是已排序的，一个是未排序的，从后端未排序部份选择一个 最小值，并放入前端已排序部份的最后一个，例如： 排序前：70 80 31 37 10 1 48 60 33 80 [1] 80 31 37 10 70 48 60 33 80 选出最小值1 [1 10] 31 37 80 70 48 60 33 80 选出最小值10 [1 10 31] 37 80 70 48 60 33 80 选出最小值31 [1 10 31 33] 80 70 48 60 37 80 \u0026hellip;\u0026hellip; [1 10 31 33 37] 70 48 60 80 80 \u0026hellip;\u0026hellip; [1 10 31 33 37 48] 70 60 80 80 \u0026hellip;\u0026hellip; [1 10 31 33 37 48 60] 70 80 80 \u0026hellip;\u0026hellip; [1 10 31 33 37 48 60 70] 80 80 \u0026hellip;\u0026hellip; [1 10 31 33 37 48 60 70 80] 80 \u0026hellip;\u0026hellip; 插入排序 像是玩朴克一样，我们将牌分作两堆，每次从后面一堆的牌抽出最前端的牌，然后插入前面一 堆牌的适当位置，例如： 排序前：92 77 67 8 6 84 55 85 43 67 [77 92] 67 8 6 84 55 85 43 67 将77插入92前 [67 77 92] 8 6 84 55 85 43 67 将67插入77前 [8 67 77 92] 6 84 55 85 43 67 将8插入67前 [6 8 67 77 92] 84 55 85 43 67 将6插入8前 [6 8 67 77 84 92] 55 85 43 67 将84插入92前 [6 8 55 67 77 84 92] 85 43 67 将55插入67前 [6 8 55 67 77 84 85 92] 43 67 \u0026hellip;\u0026hellip; [6 8 43 55 67 77 84 85 92] 67 \u0026hellip;\u0026hellip; [6 8 43 55 67 67 77 84 85 92] \u0026hellip;\u0026hellip; 气泡排序法 顾名思义，就是排序时，最大的元素会如同气泡一样移至右端，其利用比较相邻元素的方法， 将大的元素交换至右端，所以大的元素会不断的往右移动，直到适当的位置为止。 基本的气泡排序法可以利用旗标的方式稍微减少一些比较的时间，当寻访完阵列后都没有发生 任何的交换动作，表示排序已经完成，而无需再进行之后的回圈比较与交换动作，例如： 排序前：95 27 90 49 80 58 6 9 18 50 27 90 49 80 58 6 9 18 50 [95] 95浮出 27 49 80 58 6 9 18 50 [90 95] 90浮出 27 49 58 6 9 18 50 [80 90 95] 80浮出 27 49 6 9 18 50 [58 80 90 95] \u0026hellip;\u0026hellip; 27 6 9 18 49 [50 58 80 90 95] \u0026hellip;\u0026hellip; 6 9 18 27 [49 50 58 80 90 95] \u0026hellip;\u0026hellip; 6 9 18 [27 49 50 58 80 90 95] 由于接下来不会再发生交换动作，排序提早结束 在上面的例子当中，还加入了一个观念，就是当进行至i与i+1时没有交换的动作，表示接下来的 i+2至n已经排序完毕，这也增进了气泡排序的效率。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void selsort(int[]); // 选择排序\nvoid insort(int[]);\n// 插入排序\nvoid bubsort(int[]); // 气泡排序 int main(void) { int number[MAX] = {0}; int i; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } printf(\u0026quot;\\n请选择排序方式：\\n\u0026rdquo;); printf(\u0026quot;(1)选择排序\\n(2)插入排序\\n(3)气泡排序\\n:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); switch(i) { case 1: selsort(number); break; case 2: insort(number); break; case 3: bubsort(number); break; default: printf(\u0026ldquo;选项错误(1..3)\\n\u0026rdquo;); } return 0; } void selsort(int number[]) { int i, j, k, m; for(i = 0; i \u0026lt; MAX-1; i++) { m = i; for(j = i+1; j \u0026lt; MAX; j++) if(number[j] \u0026lt; number[m]) m = j; if( i != m) SWAP(number[i], number[m]) printf(\u0026ldquo;第 %d 次排序：\u0026rdquo;, i+1); for(k = 0; k \u0026lt; MAX; k++) printf(\u0026quot;%d \u0026ldquo;, number[k]); printf(\u0026quot;\\n\u0026rdquo;); } } void insort(int number[]) { int i, j, k, tmp; for(j = 1; j \u0026lt; MAX; j++) { tmp = number[j]; i = j - 1; while(tmp \u0026lt; number[i]) { number[i+1] = number[i]; i\u0026ndash;; if(i == -1) break; } number[i+1] = tmp; printf(\u0026ldquo;第 %d 次排序：\u0026rdquo;, j); for(k = 0; k \u0026lt; MAX; k++) printf(\u0026quot;%d \u0026ldquo;, number[k]); printf(\u0026quot;\\n\u0026rdquo;); } } void bubsort(int number[]) { int i, j, k, flag = 1; for(i = 0; i \u0026lt; MAX-1 \u0026amp;\u0026amp; flag == 1; i++) { flag = 0; for(j = 0; j \u0026lt; MAX-i-1; j++) { if(number[j+1] \u0026lt; number[j]) { SWAP(number[j+1], number[j]); flag = 1; } } printf(\u0026ldquo;第 %d 次排序：\u0026rdquo;, i+1); for(k = 0; k \u0026lt; MAX; k++) printf(\u0026quot;%d \u0026ldquo;, number[k]); printf(\u0026quot;\\n\u0026rdquo;); } } 34.Algorithm Gossip: Shell 排序法 - 改良的插入排序 说明 插入排序法由未排序的后半部前端取出一个值，插入已排序前半部的适当位置，概念简单但速 度不快。 排序要加快的基本原则之一，是让后一次的排序进行时，尽量利用前一次排序后的结果，以加 快排序的速度，Shell排序法即是基于此一概念来改良插入排序法。 解法 Shell排序法最初是D.L Shell于1959所提出，假设要排序的元素有n个，则每次进行插入排序时 并不是所有的元素同时进行时，而是取一段间隔。 Shell首先将间隔设定为n/2，然后跳跃进行插入排序，再来将间隔n/4，跳跃进行排序动作，再来 间隔设定为n/8、n/16，直到间隔为1之后的最 后一次排序终止，由于上一次的排序动作都会将 固定间隔内的元素排序好，所以当间隔越来越小时，某些元素位于正确位置的机率越高，因此 最后几次的排序动作将 可以大幅减低。 举个例子来说，假设有一未排序的数字如右：89 12 65 97 61 81 27 2 61 98 数字的总数共有10个，所以第一次我们将间隔设定为10 / 2 = 5，此时我们对间隔为5的数字进行 排序，如下所示： 画线连结的部份表示 要一起进行排序的部份，再来将间隔设定为5 / 2的商，也就是2，则第二 次的插入排序对象如下所示： 再来间隔设定为2 / 2 = 1，此时就是单纯的插入排序了，由于大部份的元素都已大致排序过了， 所以最后一次的插入排序几乎没作什么排序动作了： 将间隔设定为n / 2是D.L Shell最初所提出，在教科书中使用这个间隔比较好说明，然而 Shell排 序法的关键在于间隔的选定，例如Sedgewick证明选用以下的间隔可以加 快Shell排序法的速度： j 2 j j 2 j j 后来还有人证明有其它的间隔选定法可以将Shell排序法的速度再加快；另外Shell排序法的概念 也可以用来改良气泡排序法。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void shellsort(int[]); int main(void) { int number[MAX] = {0}; int i; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } shellsort(number); return 0; } void shellsort(int number[]) { int i, j, k, gap, t; gap = MAX / 2; while(gap \u0026gt; 0) { for(k = 0; k \u0026lt; gap; k++) { for(i = k+gap; i \u0026lt; MAX; i+=gap) { for(j = i - gap; j \u0026gt;= k; j-=gap) { if(number[j] \u0026gt; number[j+gap]) { SWAP(number[j], number[j+gap]); } else break; } } } printf(\u0026quot;\\ngap = %d：\u0026rdquo;, gap); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n\u0026rdquo;); gap /= 2; } } 35.Algorithm Gossip: Shaker 排序法 - 改良的气泡排序 说明 请看看之前介绍过的气泡排序法： for(i = 0; i \u0026lt; MAX-1 \u0026amp;\u0026amp; flag == 1; i++) { flag = 0; for(j = 0; j \u0026lt; MAX-i-1; j++) { if(number[j+1] \u0026lt; number[j]) { SWAP(number[j+1], number[j]); flag = 1; } } } 事实上这个气泡排序法已经不是单纯的气泡排序了，它使用了旗标与右端左移两个方法来改进 排序的效能，而Shaker排序法使用到后面这个观念进一步改良气泡排序法。 解法 在上面的气泡排序法中，交换的动作并不会一直进行至阵列的最后一个，而是会进行至MAX-i- 1，所以排序的过程中，阵列右方排序好的元素会一直增加，使得左边排序的次数逐渐减少，如 我们的例子所示： 排序前：95 27 90 49 80 58 6 9 18 50 27 90 49 80 58 6 9 18 50 [95] 95浮出 27 49 80 58 6 9 18 50 [90 95] 90浮出 27 49 58 6 9 18 50 [80 90 95] 80浮出 27 49 6 9 18 50 [58 80 90 95] \u0026hellip;\u0026hellip; 27 6 9 18 49 [50 58 80 90 95] \u0026hellip;\u0026hellip; 6 9 18 27 [49 50 58 80 90 95] \u0026hellip;\u0026hellip; 6 9 18 [27 49 50 58 80 90 95] 方括号括住的部份表示已排序完毕，Shaker排序使用了这个概念，如果让左边的元素也具有这 样的性质，让左右两边的元素都能先排序完成，如此未排序的元素会集中在中间，由于左右两 边同时排序，中间未排序的部份将会很快的减少。 方法就在于气泡排序的双向进行，先让气泡排序由左向右进行，再来让气泡排序由右往左进行， 如此完成一次排序的动作，而您必须使用left与right两个旗标来记录左右两端已排序的元素位 置。 一个排序的例子如下所示： 排序前：45 19 77 81 13 28 18 19 77 11 往右排序：19 45 77 13 28 18 19 77 11 [81] 向左排序：[11] 19 45 77 13 28 18 19 77 [81] 往右排序：[11] 19 45 13 28 18 19 [77 77 81] 向左排序：[11 13] 19 45 18 28 19 [77 77 81] 往右排序：[11 13] 19 18 28 19 [45 77 77 81] 向左排序：[11 13 18] 19 19 28 [45 77 77 81] 往右排序：[11 13 18] 19 19 [28 45 77 77 81] 向左排序：[11 13 18 19 19] [28 45 77 77 81] 如上所示，括号中表示左右两边已排序完成的部份，当left \u0026gt; right时，则排序完成。 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void shakersort(int[]); int main(void) { int number[MAX] = {0}; int i; srand(time(NULL)); 36.排序法 - 改良的选择排序 说明 选择排序法的概念简单，每次从未排序部份选一最小值，插入已排序部份的后端，其时间主要 花费于在整个未排序部份寻找最小值，如果能让搜寻最小值的方式加 快，选择排序法的速率也 就可以加快，Heap排序法让搜寻的路径由树根至最后一个树叶，而不是整个未排序部份，因而 称之为改良的选择排序法。 解法 Heap排序法使用Heap Tree（堆积树），树是一种资料结构，而堆积树是一个二元树，也就是每 一个父节点最多只有两个子节点（关于树的详细定义还请见资料结构书籍），堆积树的 父节点 若小于子节点，则称之为最小堆积（Min Heap），父节点若大于子节点，则称之为最大堆积（Max Heap），而同一层的子节点则无需理会其大小关系，例如下面就是一个堆积树： 可以使用一维阵列来储存堆积树的所有元素与其顺序，为了计算方便，使用的起始索引是1而不 是0，索引1是树根位置，如果左子节点储存在阵列中的索引为s，则其父节点的索引为s/2，而右 子节点为s+1，就如上图所示，将上图的堆积树转换为一维阵列之后如下所示： 首先必须知道如何建立堆积树，加至堆积树的元素会先放置在最后一个树叶节点位置，然后检 查父节点是否小于子节点（最小堆积），将小的元素不断与父节点交换，直到满足堆积树的条件 为止，例如在上图的堆积加入一个元素12，则堆积树的调整方式如下所示： 建立好堆积树之后，树根一定是所有元素的最小值，您的目的就是： 将最小值取出 然后调整树为堆积树 不断重复以上的步骤，就可以达到排序的效果，最小值的取出方式是将树根与最后一个树叶节 点交换，然后切下树叶节点，重新调整树为堆积树，如下所示： 调整完毕后，树根节点又是最小值了，于是我们可以重覆这个步骤，再取出最小值，并调整树 为堆积树，如下所示： 如此重覆步骤之后，由于使用一维阵列来储存堆积树，每一次将树叶与树根交换的动作就是将 最小值放至后端的阵列，所以最后阵列就是变为已排序的状态。 其实堆积在调整的过程中，就是一个选择的行为，每次将最小值选至树根，而选择的路径并不 是所有的元素，而是由树根至树叶的路径，因而可以加快选择的过程， 所以Heap排序法才会被 称之为改良的选择排序法。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void createheap(int[]); void heapsort(int[]); int main(void) { int number[MAX+1] = {-1}; int i, num; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 1; i \u0026lt;= MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } printf(\u0026quot;\\n建立堆积树：\u0026rdquo;); createheap(number); for(i = 1; i \u0026lt;= MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n\u0026rdquo;); heapsort(number); printf(\u0026quot;\\n\u0026quot;); return 0; } void createheap(int number[]) { int i, s, p; int heap[MAX+1] = {-1}; for(i = 1; i \u0026lt;= MAX; i++) { heap[i] = number[i]; s = i; p = i / 2; while(s \u0026gt;= 2 \u0026amp;\u0026amp; heap[p] \u0026gt; heap[s]) { SWAP(heap[p], heap[s]); s = p; p = s / 2; } } for(i = 1; i \u0026lt;= MAX; i++) number[i] = heap[i]; } void heapsort(int number[]) { int i, m, p, s; m = MAX; while(m \u0026gt; 1) { SWAP(number[1], number[m]); m\u0026ndash;; p = 1; s = 2 * p; while(s \u0026lt;= m) { if(s \u0026lt; m \u0026amp;\u0026amp; number[s+1] \u0026lt; number[s]) s++; if(number[p] \u0026lt;= number[s]) break; SWAP(number[p], number[s]); p = s; s = 2 * p; } printf(\u0026quot;\\n排序中：\u0026quot;); for(i = MAX; i \u0026gt; 0; i\u0026ndash;) printf(\u0026quot;%d \u0026ldquo;, number[i]); } } 37.Algorithm Gossip: 快速排序法（一） 说明快速排序法（quick sort）是目前所公认最快的排序方法之一（视解题的对象而定），虽然 2 错的。 快速排序法的基本精神是在数列中找出适当的轴心，然后将数列一分为二，分别对左边与右边 数列进行排序，而影响快速排序法效率的正是轴心的选择。 这边所介绍的第一个快速排序法版本，是在多数的教科书上所提及的版本，因为它最容易理解， 也最符合轴心分割与左右进行排序的概念，适合对初学者进行讲解。\n解法这边所介绍的快速演算如下：将最左边的数设定为轴，并记录其值为\ns\n廻圈处理： 令索引 i 从数列左方往右方找，直到找到大于 s 的数 令索引 j 从数列左右方往左方找，直到找到小于 s 的数 如果 i \u0026gt;= j，则离开回圈 如果 i \u0026lt; j，则交换索引i与j两处的值 将左侧的轴与 j 进行交换 对轴左边进行递回 对轴右边进行递回 透过以下演算法，则轴左边的值都会小于s，轴右边的值都会大于s，如此再对轴左右两边进行 递回，就可以对完成排序的目的，例如下面的实例，表示要交换的数，[]表示轴： [41] 24 76 11 45 64 21 69 19 36* [41] 24 36 11 45* 64 21 69 19* 76 [41] 24 36 11 19 64* 21* 69 45 76 [41] 24 36 11 19 21 64 69 45 76 21 24 36 11 19 [41] 64 69 45 76 在上面的例子中，41左边的值都比它小，而右边的值都比它大，如此左右再进行递回至排序完 成。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void quicksort(int[], int, int); int main(void) { int number[MAX] = {0}; int i, num; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } quicksort(number, 0, MAX-1); printf(\u0026quot;\\n排序后：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } void quicksort(int number[], int left, int right) { int i, j, s; if(left \u0026lt; right) { s = number[left]; i = left; j = right + 1; while(1) { // 向右找 while(i + 1 \u0026lt; number.length \u0026amp;\u0026amp; number[++i] \u0026lt; s) ; // 向左找 while(j -1 \u0026gt; -1 \u0026amp;\u0026amp; number[\u0026ndash;j] \u0026gt; s) ; if(i \u0026gt;= j) break; SWAP(number[i], number[j]); } number[left] = number[j]; number[j] = s;\nquicksort(number, left, j-1);\n// 对左边进行递回\nquicksort(number, j+1, right); // 对右边进行递回 } } 38.Algorithm Gossip: 快速排序法（二） 说明在快速排序法（一）中，每次将最左边的元素设为轴，而之前曾经说过，快速排序法的 加速在于轴的选择，在这个例子中，只将轴设定为中间的元素，依这个元素作基准进行比较， 这可以增加快速排序法的效率。\n解法在这个例子中，取中间的元素s作比较，同样的先得右找比s大的索引\ni，然后找比s小的\n索引 j，只要两边的索引还没有交会，就交换 i 与 j 的元素值，这次不用再进行轴的交换了， 因为在寻找交换的过程中，轴位置的元素也会参与交换的动作，例如：\n41\n24\n76\n11\n45\n64\n21\n69\n19\n36\n首先left为0，right为9，(left+right)/2 = 4（取整数的商），所以轴为索引4的位置，比较的元素是 45，您往右找比45大的，往左找比45小的进行交换：\n41 24 76* 11 41 24 36 11 41 24 36 11 [41 24 36 11\n[45] 64 21 69 19 36 45 64 21 69 19* 76 19 64* 21* 69 45 76 19 21] [64 69 45 76]\n完成以上之后，再初别对左边括号与右边括号的部份进行递回，如此就可以完成排序的目的。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void quicksort(int[], int, int); int main(void) { int number[MAX] = {0}; int i, num; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } quicksort(number, 0, MAX-1); printf(\u0026quot;\\n排序后：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } void quicksort(int number[], int left, int right) { int i, j, s; if(left \u0026lt; right) { s = number[(left+right)/2]; i = left - 1; j = right + 1; while(1) { while(number[++i] \u0026lt; s) ; // 向右找 while(number[\u0026ndash;j] \u0026gt; s) ; // 向左找 if(i \u0026gt;= j) break; SWAP(number[i], number[j]); }\nquicksort(number, left, i-1);\n// 对左边进行递回\nquicksort(number, j+1, right); // 对右边进行递回 } } 39.Algorithm Gossip: 快速排序法（三） 说明 之前说过轴的选择是快速排序法的效率关键之一，在这边的快速排序法的轴选择方式更加快了 快速排序法的效率，它是来自演算法名书 Introduction to Algorithms 之中。 解法 先说明这个快速排序法的概念，它以最右边的值 s作比较的标准，将整个数列分为三个部份， 一个是小于s的部份，一个是大于s的部份，一个是未处理的部份，如下所示 ： 在排序的过程中，i 与 j 都会不断的往右进行比较与交换，最后数列会变为以下的状态： 然后将s的值置于中间，接下来就以相同的步骤会左右两边的数列进行排序的动作，如下所示： 整个演算的过程，直接摘录书中的虚拟码来作说明： QUICKSORT(A, p, r) if p \u0026lt; r then q \u0026lt;- PARTITION(A, p, r) QUICKSORT(A, p, q-1) QUICKSORT(A, q+1, r) end QUICKSORT PARTITION(A, p, r) x \u0026lt;- A[r] i \u0026lt;- p-1 for j \u0026lt;- p to r-1 do if A[j] \u0026lt;= x then i \u0026lt;- i+1 exchange A[i]\u0026lt;-\u0026gt;A[j] exchange A[i+1]\u0026lt;-\u0026gt;A[r] return i+1 end PARTITION 一个实际例子的演算如下所示： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} int partition(int[], int, int); void quicksort(int[], int, int); int main(void) { int number[MAX] = {0}; int i, num; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number[i]); } quicksort(number, 0, MAX-1); printf(\u0026quot;\\n排序后：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } int partition(int number[], int left, int right) { int i, j, s; s = number[right]; i = left - 1; for(j = left; j \u0026lt; right; j++) { if(number[j] \u0026lt;= s) { i++; SWAP(number[i], number[j]); } } SWAP(number[i+1], number[right]); return i+1; } void quicksort(int number[], int left, int right) { int q; if(left \u0026lt; right) { q = partition(number, left, right); quicksort(number, left, q-1); quicksort(number, q+1, right); } } 40.Algorithm Gossip: 合并排序法 说明之前所介绍的排序法都是在同一个阵列中的排序，考虑今日有两笔或两笔以上的资料， 它可能是不同阵列中的资料，或是不同档案中的资料，如何为它们进行排序？ 解法可以使用合并排序法，合并排序法基本是将两笔已排序的资料合并并进行排序，如果所 读入的资料尚未排序，可以先利用其它的排序方式来处理这两笔资料，然后再将排序好的这两 笔资料合并。 有人问道，如果两笔资料本身就无排序顺序，何不将所有的资料读入，再一次进行排序？排序 的精神是尽量利用资料已排序的部份，来加快排序的效率，小笔资料的 排序较为快速，如果小 笔资料排序完成之后，再合并处理时，因为两笔资料都有排序了，所有在合并排序时会比单纯 读入所有的资料再一次排序来的有效率。 那么可不可以直接使用合并排序法本身来处理整个排序的动作？而不动用到其它的排序方式？ 答案是肯定的，只要将所有的数字不断的分为两个等分，直到最后剩一个数字为止，然后再反 过来不断的合并，就如下图所示： 不过基本上分割又会花去额外的时间，不如使用其它较好的排序法来排序小笔资料，再使用合 并排序来的有效率。 下面这个程式范例，我们使用快速排序法来处理小笔资料排序，然后再使用合并排序法处理合 并的动作。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX1 10 #define MAX2 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} int partition(int[], int, int); void quicksort(int[], int, int); void mergesort(int[], int, int[], int, int[]); int main(void) { int number1[MAX1] = {0}; int number2[MAX1] = {0}; int number3[MAX1+MAX2] = {0}; int i, num; srand(time(NULL)); printf(\u0026ldquo;排序前：\u0026rdquo;); printf(\u0026quot;\\nnumber1[]：\u0026rdquo;); for(i = 0; i \u0026lt; MAX1; i++) { number1[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number1[i]); } printf(\u0026quot;\\nnumber2[]：\u0026rdquo;); for(i = 0; i \u0026lt; MAX2; i++) { number2[i] = rand() % 100; printf(\u0026quot;%d \u0026ldquo;, number2[i]); } // 先排序两笔资料 quicksort(number1, 0, MAX1-1); quicksort(number2, 0, MAX2-1); printf(\u0026quot;\\n排序后：\u0026rdquo;); printf(\u0026quot;\\nnumber1[]：\u0026quot;); for(i = 0; i \u0026lt; MAX1; i++) printf(\u0026quot;%d \u0026ldquo;, number1[i]); printf(\u0026quot;\\nnumber2[]：\u0026rdquo;); for(i = 0; i \u0026lt; MAX2; i++) printf(\u0026quot;%d \u0026ldquo;, number2[i]); // 合并排序 mergesort(number1, MAX1, number2, MAX2, number3); printf(\u0026quot;\\n合并后：\u0026rdquo;); for(i = 0; i \u0026lt; MAX1+MAX2; i++) printf(\u0026quot;%d \u0026ldquo;, number3[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } int partition(int number[], int left, int right) { int i, j, s; s = number[right]; i = left - 1; for(j = left; j \u0026lt; right; j++) { if(number[j] \u0026lt;= s) { i++; SWAP(number[i], number[j]); } } SWAP(number[i+1], number[right]); return i+1; } void quicksort(int number[], int left, int right) { int q; if(left \u0026lt; right) { q = partition(number, left, right); quicksort(number, left, q-1); quicksort(number, q+1, right); } } void mergesort(int number1[], int M, int number2[], int N, int number3[]) { int i = 0, j = 0, k = 0; while(i \u0026lt; M \u0026amp;\u0026amp; j \u0026lt; N) { if(number1[i] \u0026lt;= number2[j]) number3[k++] = number1[i++]; else number3[k++] = number2[j++]; } while(i \u0026lt; M) number3[k++] = number1[i++]; while(j \u0026lt; N) number3[k++] = number2[j++]; } 41.Algorithm Gossip: 基数排序法\n说明在之前所介绍过的排序方法，都是属于「比较性」的排序法，也就是每次排序时\n，都是\n比较整个键值的大小以进行排序。 这边所要介绍的「基数排序法」（radix sort）则是属于「分配式排序」（distribution sort）， 基数 排序法又称「桶子法」（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排 序的元素分配至某些「桶」中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时 间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率 高于其它的比较性排序法。 解法基数排序的方式可以采用LSD（Least sgnificant digital）或MSD（Most sgnificant digital）， LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 以LSD为例，假设原来有一串数值如下所示： 73, 22, 93, 43, 55, 14, 28, 65, 39, 81 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n81\n65\n39\n43\n14\n55\n28\n93\n22\n73\n接下来将这些桶子中的数值重新串接起来，成为以下的数列： 81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配：\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n28\n39\n14\n22\n43\n55\n65\n73\n81\n93\n接下来将这些桶子中的数值重新串接起来，成为以下的数列： 14, 22, 28, 39, 43, 55, 65, 73, 81, 93 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最 高位数为止。 LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好，MSD的方 式恰与LSD相反，是由高位数为基底开始进行分配，其他的演 算方式则都相同。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int data[10] = {73, 22, 93, 43, 55, 14, 28, 65, 39, 81}; int temp[10][10] = {0}; int order[10] = {0}; int i, j, k, n, lsd; k = 0; n = 1; printf(\u0026quot;\\n排序前: \u0026ldquo;); for(i = 0; i \u0026lt; 10; i++) printf(\u0026quot;%d \u0026ldquo;, data[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); while(n \u0026lt;= 10) { for(i = 0; i \u0026lt; 10; i++) { lsd = ((data[i] / n) % 10); temp[lsd][order[lsd]] = data[i]; order[lsd]++; } printf(\u0026quot;\\n重新排列: \u0026ldquo;); for(i = 0; i \u0026lt; 10; i++) { if(order[i] != 0) for(j = 0; j \u0026lt; order[i]; j++) { data[k] = temp[i][j]; printf(\u0026quot;%d \u0026ldquo;, data[k]); k++; } order[i] = 0; } n *= 10; k = 0; } putchar(\u0026rsquo;\\n\u0026rsquo;); printf(\u0026quot;\\n排序后: \u0026ldquo;); for(i = 0; i \u0026lt; 10; i++) printf(\u0026quot;%d \u0026ldquo;, data[i]); return 0; } 42.Algorithm Gossip: 循序搜寻法（使用卫兵） 说明 搜寻的目的，是在「已排序的资料」中寻找指定的资料，而当中循序搜寻是最基本的搜寻法， 只要从资料开头寻找到最后，看看是否找到资料即可。 解法 初学者看到循序搜寻，多数都会使用以下的方式来进行搜寻： while(i \u0026lt; MAX) { if(number[i] == k) { printf(\u0026ldquo;找到指定值\u0026rdquo;); break; } i++; } 这个方法基本上没有错，但是可以加以改善，可以利用设定卫兵的方式，省去if判断式，卫兵通 常设定在数列最后或是最前方，假设设定在列前方好了（索引0的 位置），我们从数列后方向前 找，如果找到指定的资料时，其索引值不是0，表示在数列走访完之前就找到了，在程式的撰写 上，只要使用一个while回圈就可 以了。 下面的程式为了配合卫兵的设置，自行使用快速排序法先将产生的数列排序，然后才进行搜寻， 若只是数字的话，通常您可以使用程式语言函式库所提供的搜寻函式。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} int search(int[]); int partition(int[], int, int); void quicksort(int[], int, int); int main(void) { int number[MAX+1] = {0}; int i, find; srand(time(NULL)); for(i = 1; i \u0026lt;= MAX; i++) number[i] = rand() % 100; quicksort(number, 1, MAX); printf(\u0026ldquo;数列：\u0026rdquo;); for(i = 1; i \u0026lt;= MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n输入搜寻值：\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;number[0]); if(find = search(number)) printf(\u0026quot;\\n找到数值于索引 %d \u0026ldquo;, find); else printf(\u0026quot;\\n找不到数值\u0026rdquo;); printf(\u0026quot;\\n\u0026rdquo;); return 0; } int search(int number[]) { int i, k; k = number[0]; i = MAX; while(number[i] != k) i\u0026ndash;; return i; } int partition(int number[], int left, int right) { int i, j, s; s = number[right]; i = left - 1; for(j = left; j \u0026lt; right; j++) { if(number[j] \u0026lt;= s) { i++; SWAP(number[i], number[j]); } } SWAP(number[i+1], number[right]); return i+1; } void quicksort(int number[], int left, int right) { int q; if(left \u0026lt; right) { q = partition(number, left, right); quicksort(number, left, q-1); quicksort(number, q+1, right); } } 43.Algorithm Gossip: 二分搜寻法（搜寻原则的代表） 说明如果搜寻的数列已经有排序，应该尽量利用它们已排序的特性，以减少搜寻比对的次数， 这是搜寻的基本原则，二分搜寻法是这个基本原则的代表。 解法在二分搜寻法中，从数列的中间开始搜寻，如果这个数小于我们所搜寻的数，由于数列 已排序，则该数左边的数一定都小于要搜寻的对象，所以无需浪费时间在左边的数；如果搜寻 的数大于所搜寻的对象，则右边的数无需再搜寻，直接搜寻左边的数。 所以在二分搜寻法中，将数列不断的分为两个部份，每次从分割的部份中取中间数比对，例如 要搜寻92于以下的数列，首先中间数索引为(0+9)/2 = 4（索引由0开 始 ）： [3 24 57 57 67 68 83 90 92 95] 由于67小于92，所以转搜寻右边的数列： 3 24 57 57 67 [68 83 90 92 95] 由于90小于92，再搜寻右边的数列，这次就找到所要的数了： 3 24 57 57 67 68 83 90 [92 95] #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void quicksort(int[], int, int); int bisearch(int[], int); int main(void) { int number[MAX] = {0}; int i, find; srand(time(NULL)); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; } quicksort(number, 0, MAX-1); printf(\u0026ldquo;数列：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n输入寻找对象：\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;find); if((i = bisearch(number, find)) \u0026gt;= 0) printf(\u0026ldquo;找到数字于索引 %d \u0026ldquo;, i); else printf(\u0026quot;\\n找不到指定数\u0026rdquo;); printf(\u0026quot;\\n\u0026rdquo;); return 0; } int bisearch(int number[], int find) { int low, mid, upper; low = 0; upper = MAX - 1; while(low \u0026lt;= upper) { mid = (low+upper) / 2; if(number[mid] \u0026lt; find) low = mid+1; else if(number[mid] \u0026gt; find) upper = mid - 1; else return mid; } return -1; } void quicksort(int number[], int left, int right) { int i, j, k, s; if(left \u0026lt; right) { s = number[(left+right)/2]; i = left - 1; j = right + 1; while(1) { while(number[++i] \u0026lt; s) ; // 向右找 while(number[\u0026ndash;j] \u0026gt; s) ; // 向左找 if(i \u0026gt;= j) break; SWAP(number[i], number[j]); }\nquicksort(number, left, i-1);\n// 对左边进行递回\nquicksort(number, j+1, right); // 对右边进行递回 } } 44.Algorithm Gossip: 插补搜寻法 说明 如果却搜寻的资料分布平均的话，可以使用插补（ Interpolation）搜寻法来进行搜寻，在搜寻 的对象大于500时，插补搜寻法会比 二分搜寻法 来的快速。 解法 插补搜寻法是以资料分布的近似直线来作比例运算，以求出中间的索引并进行资料比对，如果 取出的值小于要寻找的值，则提高下界，如果取出的值大于要寻找的 值，则降低下界，如此不 断的减少搜寻的范围，所以其本原则与二分搜寻法是相同的，至于中间值的寻找是透过比例运 算，如下所示，其中K是指定要寻找的对象， 而m则是可能的索引值： 实作 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 10 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void quicksort(int[], int, int); int intsrch(int[], int); int main(void) { int number[MAX] = {0}; int i, find; srand(time(NULL)); for(i = 0; i \u0026lt; MAX; i++) { number[i] = rand() % 100; } quicksort(number, 0, MAX-1); printf(\u0026ldquo;数列：\u0026rdquo;); for(i = 0; i \u0026lt; MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n输入寻找对象：\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;find); if((i = intsrch(number, find)) \u0026gt;= 0) printf(\u0026ldquo;找到数字于索引 %d \u0026ldquo;, i); else printf(\u0026quot;\\n找不到指定数\u0026rdquo;); printf(\u0026quot;\\n\u0026rdquo;); return 0; } int intsrch(int number[], int find) { int low, mid, upper; low = 0; upper = MAX - 1; while(low \u0026lt;= upper) { mid = (upper-low)* (find-number[low])/(number[upper]-number[low])\n low; if(mid \u0026lt; low || mid \u0026gt; upper) return -1; if(find \u0026lt; number[mid]) upper = mid - 1; else if(find \u0026gt; number[mid]) low = mid + 1; else return mid; } return -1; } void quicksort(int number[], int left, int right) { int i, j, k, s; if(left \u0026lt; right) { s = number[(left+right)/2]; i = left - 1; j = right + 1; while(1) { while(number[++i] \u0026lt; s) ; // 向右找 while(number[\u0026ndash;j] \u0026gt; s) ; // 向左找 if(i \u0026gt;= j) break; SWAP(number[i], number[j]); }  quicksort(number, left, i-1);\n// 对左边进行递回\nquicksort(number, j+1, right); // 对右边进行递回 } } 45.Algorithm Gossip: 费氏搜寻法 说明 二分搜寻法每次搜寻时，都会将搜寻区间分为一半，所以其搜寻时间为O(log(2)n)，log(2)表示 以2为底的log值，这边要介绍的费氏搜寻，其利用费氏数列作为间隔来搜寻下一个数，所以区 间收敛的速度更快，搜寻时间为O(logn)。 解法 费氏搜寻使用费氏数列来决定下一个数的搜寻位置，所以必须先制作费氏数列，这在之前有提 过；费氏搜寻会先透过公式计算求出第一个要搜寻数的位置，以及其代 表的费氏数，以搜寻对 象10个数字来说，第一个费氏数经计算后一定是F5，而第一个要搜寻的位置有两个可能，例如 若在下面的数列搜寻的话（为了计算方便， 通常会将索引0订作无限小的数，而数列由索引1 开 始 ）： -infin; 1 3 5 7 9 13 15 17 19 20 如果要搜寻5的话，则由索引F5 = 5开始搜寻，接下来如果数列中的数小于指定搜寻值时，就往 左找，大于时就向右，每次找的间隔是F4、F3、F2来寻找，当费氏数为0时还没找到，就表示 寻找失败，如下所示： 由于第一个搜寻值索引F5 = 5处的值小于19，所以此时必须对齐数列右方，也就是将第一个搜 寻值的索引改为F5+2 = 7，然后如同上述的方式进行搜寻，如下所示： 至于第一个搜寻值是如何找到的？我们可以由以下这个公式来求得，其中n为搜寻对象的个数： Fx + m = n Fx \u0026lt;= n 也就是说Fx必须找到不大于n的费氏数，以10个搜寻对象来说： Fx + m = 10 取Fx = 8, m = 2，所以我们可以对照费氏数列得x = 6，然而第一个数的可能位置之一并不是F6， 而是第x-1的费氏数，也就是F5 = 5。 如果数列number在索引5处的值小于指定的搜寻值，则第一个搜寻位置就是索引5的位置，如果 大于指定的搜寻值，则第一个搜寻位置必须加上m，也就是F5 + m = 5 + 2 = 7，也就是索引7的 位置，其实加上m的原因，是为了要让下一个搜寻值刚好是数列的最后一个位置。 费氏搜寻看来难懂，但只要掌握Fx + m = n这个公式，自己找几个实例算一次，很容易就可以理 解；费氏搜寻除了收敛快速之外，由于其本身只会使用到加法与减法，在运算上也可以加快。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MAX 15 #define SWAP(x,y) {int t; t = x; x = y; y = t;}\nvoid createfib(void); int findx(int, int);\n// 建立费氏数列 // 找x值\nint fibsearch(int[], int); // 费氏搜寻 void quicksort(int[], int, int); // 快速排序 int Fib[MAX] = {-999}; int main(void) { int number[MAX] = {0}; int i, find; srand(time(NULL)); for(i = 1; i \u0026lt;= MAX; i++) { number[i] = rand() % 100; } quicksort(number, 1, MAX); printf(\u0026ldquo;数列：\u0026rdquo;); for(i = 1; i \u0026lt;= MAX; i++) printf(\u0026quot;%d \u0026ldquo;, number[i]); printf(\u0026quot;\\n输入寻找对象：\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;find); if((i = fibsearch(number, find)) \u0026gt;= 0) printf(\u0026ldquo;找到数字于索引 %d \u0026ldquo;, i); else printf(\u0026quot;\\n找不到指定数\u0026rdquo;); printf(\u0026quot;\\n\u0026rdquo;); return 0; } // 建立费氏数列 void createfib(void) { int i; Fib[0] = 0; Fib[1] = 1; for(i = 2; i \u0026lt; MAX; i++) Fib[i] = Fib[i-1] + Fib[i-2]; } // 找 x 值 int findx(int n, int find) { int i = 0; while(Fib[i] \u0026lt;= n) i++; i\u0026ndash;; return i; } // 费式搜寻 int fibsearch(int number[], int find) { int i, x, m; createfib(); x = findx(MAX+1,find); m = MAX - Fib[x]; printf(\u0026quot;\\nx = %d, m = %d, Fib[x] = %d\\n\\n\u0026rdquo;, x, m, Fib[x]); x\u0026ndash;; i = x; if(number[i] \u0026lt; find) i += m; while(Fib[x] \u0026gt; 0) { if(number[i] \u0026lt; find) i += Fib[\u0026ndash;x]; else if(number[i] \u0026gt; find) i -= Fib[\u0026ndash;x]; else return i; } return -1; } void quicksort(int number[], int left, int right) { int i, j, k, s; if(left \u0026lt; right) { s = number[(left+right)/2]; i = left - 1; j = right + 1; while(1) { while(number[++i] \u0026lt; s) ; // 向右找 while(number[\u0026ndash;j] \u0026gt; s) ; // 向左找 if(i \u0026gt;= j) break; SWAP(number[i], number[j]); }\nquicksort(number, left, i-1);\n// 对左边进行递回\nquicksort(number, j+1, right); // 对右边进行递回 } } 46.Algorithm Gossip: 稀疏矩阵 说明 如果在矩阵中，多数的元素并没有资料，称此矩阵为稀疏矩阵（sparse matrix）， 由于矩阵在程 式中常使用二维阵列表示，二维阵列的大小与使用的记忆体空间成正比，如果多数的元素没有 资料，则会造成记忆体空间的浪费，为 此，必须设计稀疏矩阵的阵列储存方式，利用较少的记 忆体空间储存完整的矩阵资讯。 解法 在这边所介绍的方法较为简单，阵列只储存矩阵的行数、列数与有资料的索引位置及其值，在 需要使用矩阵资料时，再透过程式运算加以还原，例如若矩阵资料如下 ，其中0表示矩阵中该 位置没有资料： 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 6 0 0 0 0 9 0 0 0 0 0 0 0 12 0 这个矩阵是5X6矩阵，非零元素有4个，您要使用的阵列第一列记录其列数、行数与非零元素个 数： 5 6 4 阵列的第二列起，记录其位置的列索引、行索引与储存值： 1 1 3 2 3 6 3 2 9 4 4 12 所以原本要用30个元素储存的矩阵资讯，现在只使用了15个元素来储存，节省了不少记忆体的 使用。 C #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int num[5][3] = {{5, 6, 4}, {1, 1, 3}, {2, 3, 6}, {3, 2, 9}, {4, 4, 12}}; int i, j, k = 1; printf(\u0026ldquo;sparse matrix：\\n\u0026rdquo;); for(i = 0; i \u0026lt; 5; i++) { for(j = 0; j \u0026lt; 3; j++) { printf(\u0026quot;%4d\u0026quot;, num[i][j]); } putchar(\u0026rsquo;\\n\u0026rsquo;); } printf(\u0026quot;\\nmatrix还原：\\n\u0026quot;); for(i = 0; i \u0026lt; num[0][0]; i++) { for(j = 0; j \u0026lt; num[0][1]; j++) { if(k \u0026lt; num[0][2] \u0026amp;\u0026amp; i == num[k][0] \u0026amp;\u0026amp; j == num[k][1]) { printf(\u0026quot;%4d \u0026ldquo;, num[k][2]); k++; } else printf(\u0026quot;%4d \u0026ldquo;, 0); } putchar(\u0026rsquo;\\n\u0026rsquo;); } return 0; } 47.Algorithm Gossip: 多维矩阵转一维矩阵 说明 有的时候，为了运算方便或资料储存的空间问题，使用一维阵列会比二维或多维阵列来得方便 ， 例如上三角矩阵、下三角矩阵或对角矩阵，使用一维阵列会比使用二维阵列来得节省空间。 解法 以二维阵列转一维阵列为例，索引值由0开始，在由二维阵列转一维阵列时，我们有两种方式： 「以列（Row）为主」或「以行（Column）为主」。由于 C/C++、Java等的记忆体配置方式都是 以列为主，所以您可能会比较熟悉前者（Fortran的记忆体配置方式是以行为主）。 以列为主的二维阵列要转为一维阵列时，是将二维阵列由上往下一列一列读入一维阵列，此时 索引的对应公式如下所示，其中row与column是二维阵列索引，loc表示对应的一维阵列索引： loc = column + row行数 以行为主的二维阵列要转为一维阵列时，是将二维阵列由左往右一行一行读入一维阵列，此时 索引的对应公式如下所示： loc = row + column列数 公式的推导您画图看看就知道了，如果是三维阵列，则公式如下所示，其中i（个数u1）、 j（个 数u2）、 k（个数u3）分别表示三维阵列的三个索引： 以列为主：loc = iu2u3 + ju3 + k 以行为主：loc = ku1u2 + ju1 + i 更高维度的可以自行依此类推，但通常更高维度的建议使用其它资料结构（例如物件包装）会 比较具体，也不易搞错。 在C/C++中若使用到指标时，会遇到指标运算与记忆体空间位址的处理问题，此时也是用到这 边的公式，不过必须在每一个项上乘上资料型态的记忆体大小。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int arr1[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}; int arr2[12] = {0}; int row, column, i; printf(\u0026ldquo;原二维资料：\\n\u0026rdquo;); for(row = 0; row \u0026lt; 3; row++) { for(column = 0; column \u0026lt; 4; column++) { printf(\u0026quot;%4d\u0026rdquo;, arr1[row][column]); } printf(\u0026quot;\\n\u0026rdquo;); } printf(\u0026quot;\\n以列为主：\u0026quot;); for(row = 0; row \u0026lt; 3; row++) { for(column = 0; column \u0026lt; 4; column++) { i = column + row * 4; arr2[i] = arr1[row][column]; } } for(i = 0; i \u0026lt; 12; i++) printf(\u0026quot;%d \u0026ldquo;, arr2[i]); printf(\u0026quot;\\n以行为主：\u0026rdquo;); for(row = 0; row \u0026lt; 3; row++) { for(column = 0; column \u0026lt; 4; column++) { i = row + column * 3; arr2[i] = arr1[row][column]; } } for(i = 0; i \u0026lt; 12; i++) printf(\u0026quot;%d \u0026ldquo;, arr2[i]); printf(\u0026quot;\\n\u0026rdquo;); return 0; } 48.Algorithm Gossip: 上三角、下三角、对称矩阵 说明 上三角矩阵是矩阵在对角线以下的元素均为0，即Aij = 0，i \u0026gt; j，例如：\n1 0 0\n2 6 0\n3 7 10\n4 8\n5 9 11 12\n0\n0\n0\n13\n14\n0\n0\n0\n0 15\n下三角矩阵是矩阵在对角线以上的元素均为0，即Aij = 0，i \u0026lt; j，例如：\n1 2 3 4 5\n0 6 7 8 9\n0 0 10 11 12\n0 0 0 13 14\n0 0 0 0 15\n对称矩阵是矩阵元素对称于对角线，例如：\n1 2 3 2 6 7\n4 5 8 9\n3 7 10 11 12 4 8 11 13 14 5 9 12 14 15 上三角或下三角矩阵也有大部份的元素不储存值（为0），我们可以将它们使用一维阵列来储存 以节省储存空间，而对称矩阵因为对称于对角线，所以可以视为上三角或下三角矩阵来储存。 解法 假设矩阵为nxn，为了计算方便，我们让阵列索引由1开始，上三角矩阵化为一维阵列，若以 列为主，其公式为：loc = n*(i-1) - i*(i-1)/2 + j 化为以行为主，其公式为：loc = j*(j-1)/2 + i 下三角矩阵化为一维阵列，若以列为主，其公式为：loc = i*(i-1)/2 + j 若以行为主，其公式为：loc = n*(j-1) - j*(j-1)/2 + i 公式的导证其实是由等差级数公式得到，您可以自行绘图并看看就可以导证出来，对于C/C++ 或Java等索引由0开始的语言来说，只要将i与j各加1，求得loc之后减1即可套用以上的公式。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 5 int main(void) { int arr1[N][N] = {\n{1, 2, 3, 4, {0, 6, 7, 8,\n5}, 9},\n{0, 0, 10, 11, 12}, {0, 0, 0, 13, 14}, {0, 0, 0, 0, 15}}; int arr2[N*(1+N)/2] = {0}; int i, j, loc = 0; printf(\u0026ldquo;原二维资料：\\n\u0026rdquo;); for(i = 0; i \u0026lt; N; i++) { for(j = 0; j \u0026lt; N; j++) { printf(\u0026quot;%4d\u0026quot;, arr1[i][j]); } printf(\u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\n以列为主：\u0026quot;); for(i = 0; i \u0026lt; N; i++) { for(j = 0; j \u0026lt; N; j++) { if(arr1[i][j] != 0) arr2[loc++] = arr1[i][j]; } } for(i = 0; i \u0026lt; N*(1+N)/2; i++) printf(\u0026quot;%d \u0026ldquo;, arr2[i]); printf(\u0026quot;\\n输入索引(i, j)：\u0026rdquo;); scanf(\u0026quot;%d, %d\u0026quot;, \u0026amp;i, \u0026amp;j); loc = Ni - i(i+1)/2 + j; printf(\u0026quot;(%d, %d) = %d\u0026quot;, i, j, arr2[loc]); printf(\u0026quot;\\n\u0026quot;); return 0; } 49.Algorithm Gossip: 奇数魔方阵 说明 将1到n(为奇数)的数字排列在nxn的方阵上，且各行、各列与各对角线的和必须相同，如下所 示： 解法 填魔术方阵的方法以奇数最为简单，第一个数字放在第一行第一列的正中央，然后向右 (左)上 填，如果右(左)上已有数字，则向下填，如下图所示： 一般程式语言的阵列索引多由0开始，为了计算方便，我们利用索引1到n的部份，而在计算是向 右(左)上或向下时，我们可以将索引值除以n值，如果得到余数为1就向下，否则就往右(左)上 ， 原理很简单，看看是不是已经在同一列上绕一圈就对了。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 5 int main(void) { int i, j, key; int square[N+1][N+1] = {0}; i = 0; j = (N+1) / 2; for(key = 1; key \u0026lt;= NN; key++) { if((key % N) == 1) i++; else { i\u0026ndash;; j++; } if(i == 0) i = N; if(j \u0026gt; N) j = 1; square[i][j] = key; } for(i = 1; i \u0026lt;= N; i++) { for(j = 1; j \u0026lt;= N; j++) printf(\u0026quot;%2d \u0026ldquo;, square[i][j]); } return 0; } 50.Algorithm Gossip: 4N 魔方阵 说明 与 奇数魔术方阵 相同，在于求各行、各列与各对角线的和相等，而这次方阵的维度是4的倍 数。 解法 先来看看4X4方阵的解法： 简单的说，就是一个从左上由1依序开始填，但遇对角线不填，另一个由左上由16开始填，但只 填在对角线，再将两个合起来就是解答了；如果N大于2，则以 4X4为单位画对角线： 至于对角线的位置该如何判断，有两个公式，有兴趣的可以画图印证看看，如下所示： 左上至右下：j % 4 == i % 4 右上至左下：(j % 4 + i % 4) == 1 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 8 int main(void) { int i, j; int square[N+1][N+1] = {0}; for(j = 1; j \u0026lt;= N; j++) { for(i = 1; i \u0026lt;= N; i++){ if(j % 4 == i % 4 || (j % 4 + i % 4) == 1) square[i][j] = (N+1-i) * N -j + 1; else square[i][j] = (i - 1) * N + j; } } for(i = 1; i \u0026lt;= N; i++) { for(j = 1; j \u0026lt;= N; j++) printf(\u0026quot;%2d \u0026ldquo;, square[i][j]); printf(\u0026quot;\\n\u0026rdquo;); } return 0; } 51.Algorithm Gossip: 2(2N+1) 魔方阵 说明方阵的维度整体来看是偶数，但是其实是一个奇数乘以一个偶数，例如6X6，其中 6=2X3， 我们也称这种方阵与单偶数方阵。 解法如果您会解奇数魔术方阵，要解这种方阵也就不难理解，首先我们令n=2(2m+1)，并将整 个方阵看作是数个奇数方阵的组合，如下所示： 首先依序将A、B、C、D四个位置，依奇数方阵的规则填入数字，填完之后，方阵中各行的和 就相同了，但列与对角线则否，此时必须在A-D与C- B之间，作一些对应的调换，规则如下： 将A中每一列(中间列除外)的头m个元素，与D中对应位置的元素调换。 将A的中央列、中央那一格向左取m格，并与D中对应位置对调 将C中每一列的倒数m-1个元素，与B中对应的元素对调 举个实例来说，如何填6X6方阵，我们首先将之分解为奇数方阵，并填入数字，如下所示： 接下来进行互换的动作，互换的元素以不同颜色标示，如下： 由于m-1的数为0，所以在这个例子中，C-B部份并不用进行对调。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 6 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void magic_o(int [][N], int); void exchange(int [][N], int); int main(void) { int square[N][N] = {0}; int i, j; magic_o(square, N/2); exchange(square, N); for(i = 0; i \u0026lt; N; i++) { for(j = 0; j \u0026lt; N; j++) printf(\u0026quot;%2d \u0026ldquo;, square[i][j]); printf(\u0026quot;\\n\u0026rdquo;); } return 0; } void magic_o(int square[][N], int n) { int count, row, column; row = 0; column = n / 2; for(count = 1; count \u0026lt;= nn; count++) {\nsquare[row][column] = count;\n// 填A\nsquare[row+n][column+n] = count + nn; // 填B square[row][column+n] = count + 2nn; // 填C square[row+n][column] = count + 3n*n; // 填D if(count % n == 0) row++; else { row = (row == 0) ? n - 1 : row - 1 ; column = (column == n-1) ? 0 : column + 1; } } } void exchange(int x[][N], int n) { int i, j; int m = n / 4; int m1 = m - 1; for(i = 0; i \u0026lt; n/2; i++) { if(i != m) {\nfor(j = 0; j \u0026lt; m; j++) SWAP(x[i][j], x[n/2+i][j]); for(j = 0; j \u0026lt; m1; j++)\n// 处理规则 1 // 处理规则 2\nSWAP(x[i][n-1-j], x[n/2+i][n-1-j]); } else { // 处理规则 3 for(j = 1; j \u0026lt;= m; j++) SWAP(x[m][j], x[n/2+m][j]); for(j = 0; j \u0026lt; m1; j++) SWAP(x[m][n-1-j], x[n/2+m][n-1-j]); } } }\n","permalink":"https://yzqtpl.github.io/hugo-blog/post/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/","summary":"1.河内之塔.. 2.Algorithm Gossip: 费式数列. 3. 巴斯卡三角形 4.Algorithm Gossip: 三色棋 5.Algorithm Gossip: 老鼠走迷官（一） 6.Algorithm Gossip: 老鼠走迷官（二） 7.Algorithm Gossip: 骑士走棋盘 8.Algorithm Gossip: 八皇后 9.Algorithm Gossip: 八枚银币. 10.Algorithm Gossip: 生命游戏. 11.Algorithm Gossip: 字串核对 12.Algorithm Gossip: 双色、三色河内塔 13.Algorithm Gossip: 背包问题（Knapsack Problem 14.Algorithm Gossip: 蒙地卡罗法求 PI 15.Algorithm Gossip: Eratosthenes 筛选求质数 16.Algorithm Gossip: 超长整数运算（大数运算）. 17.Algorithm Gossip: 长 PI. 18.Algorithm Gossip: 最大公因数、最小公倍数、因式分解 19.Algorithm Gossip: 完美数\u0026hellip; 20.Algorithm Gossip: 阿姆斯壮数. 21.Algorithm Gossip: 最大访客数\u0026hellip;. 22.Algorithm Gossip: 中序式转后序式（前序式）\u0026hellip; 23.Algorithm Gossip: 后序式的运算. 24.","title":""},{"content":"","permalink":"https://yzqtpl.github.io/hugo-blog/post/readme/","summary":"","title":"首页"}]